/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright © 2016-2017 Mapbox, Inc.
 * This code available under the terms of the BSD 2-Clause license.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("regl")):"function"==typeof define&&define.amd?define(["exports","regl"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).megaplot=e.megaplot||{},e.REGL)}(this,(function(e,t){"use strict";function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=i(t);function s(e,t,i,r){return new(i||(i=Promise))((function(s,a){function n(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(n,o)}l((r=r.apply(e,t||[])).next())}))}const a=Object.freeze(["r","g","b","a"]),n=Object.freeze({dataChannelCount:4,desiredSwatchCapacity:1/0,attributes:[{attributeName:"TransitionTimeMs",isTimestamp:!0},{attributeName:"PositionWorld",isInterpolable:!0,components:["X","Y"]},{attributeName:"SizeWorld",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"GeometricZoom",isInterpolable:!0,isBroadcastable:!0,components:["X","Y"]},{attributeName:"PositionPixel",isInterpolable:!0,components:["X","Y"]},{attributeName:"SizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"MaxSizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"MinSizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"PositionRelative",isInterpolable:!0,components:["X","Y"]},{attributeName:"Sides"},{attributeName:"ShapeTexture",components:["U","V","Width","Height"]},{attributeName:"BorderRadiusWorld",isInterpolable:!0},{attributeName:"BorderRadiusPixel",isInterpolable:!0},{attributeName:"BorderPlacement",isInterpolable:!0},{attributeName:"BorderColor",isInterpolable:!0,components:["R","G","B","Opacity"]},{attributeName:"FillBlend",isInterpolable:!0},{attributeName:"FillColor",isInterpolable:!0,components:["R","G","B","Opacity"]},{attributeName:"FillTexture",components:["U","V","Width","Height"]}]});class o{constructor(e){const t=Object.assign({},n,e||{});if(!isFinite(t.maxTextureSize)&&!isFinite(t.desiredSwatchCapacity))throw new Error("Cannot map attributes to texture of infinite size.");this.dataChannelCount=t.dataChannelCount,this.maxTextureSize=t.maxTextureSize,this.desiredSwatchCapacity=t.desiredSwatchCapacity,this.attributes=t.attributes,this.attributeComponentIndices={},this.attributeComponentNames=[],this.isAttributeTimestamp=[];for(const e of this.attributes){const{attributeName:t,components:i}=e;for(const r of i||[""]){const i=`${t}${r}`;if(i in this.attributeComponentIndices)throw new Error(`Duplicate attribute component name detected: ${i}`);const s=this.attributeComponentNames.length;this.attributeComponentNames[s]=i,this.attributeComponentIndices[i]=s,this.isAttributeTimestamp[s]=!!e.isTimestamp}}for(const e of this.attributes){if(!e.isInterpolable)continue;const{attributeName:t,components:i}=e;for(const r of i||[""]){const i=`${t}${r}Delta`;if(i in this.attributeComponentIndices)throw new Error(`Duplicate attribute component name detected: ${i}`);const s=this.attributeComponentNames.length;this.attributeComponentNames[s]=i,this.attributeComponentIndices[i]=s,this.isAttributeTimestamp[s]=!!e.isTimestamp}}Object.freeze(this.attributeComponentIndices),Object.freeze(this.attributeComponentNames),Object.freeze(this.isAttributeTimestamp),this.texelsPerSwatch=Math.ceil(this.attributeComponentNames.length/this.dataChannelCount),this.valuesPerSwatch=this.texelsPerSwatch*this.dataChannelCount,this.bytesPerSwatch=4*this.valuesPerSwatch,this.swatchesPerRow=Math.floor(this.maxTextureSize/this.texelsPerSwatch),this.textureWidth=this.texelsPerSwatch*this.swatchesPerRow,this.textureHeight=this.maxTextureSize,this.totalSwatches=this.swatchesPerRow*this.textureHeight,this.totalSwatches>this.desiredSwatchCapacity&&(this.swatchesPerRow=Math.min(this.swatchesPerRow,Math.ceil(Math.sqrt(this.desiredSwatchCapacity/this.texelsPerSwatch))),this.textureWidth=this.texelsPerSwatch*this.swatchesPerRow,this.textureHeight=Math.min(this.textureHeight,Math.ceil(this.desiredSwatchCapacity/this.swatchesPerRow)),this.totalSwatches=this.swatchesPerRow*this.textureHeight),this.valuesPerRow=this.swatchesPerRow*this.valuesPerSwatch,this.bytesPerRow=4*this.valuesPerRow,this.totalTexels=this.textureWidth*this.textureHeight,this.totalValues=this.totalTexels*this.dataChannelCount,this.totalBytes=4*this.totalValues,Object.freeze(this)}generateTexelReaderGLSL(e="texelValues",t="dataTexture",i="instanceSwatchUv"){const r=[],s=this.texelsPerSwatch;for(let a=0;a<s;a++){const s=(a%this.texelsPerSwatch+.5)/this.texelsPerSwatch/this.swatchesPerRow,n=(Math.floor(a/this.texelsPerSwatch)+.5)/this.textureHeight;r.push(`${e}[${a}] = texture2D(${t}, ${i} + vec2(${s}, ${n}));`)}return r.join("\n")}generateAttributeDefinesGLSL(e,t="texelValues"){return[...this.attributes.map((i=>{const{attributeName:r}=i,s=(i.components||[""]).map((e=>{const i=this.attributeComponentIndices[`${r}${e}`],s=Math.floor(i/this.dataChannelCount),n=a[i%this.dataChannelCount];return`${t}[${s}].${n}`})).join(", "),n=i.components?`vec${i.components.length}(${s})`:s;return`#define ${e}${r}() ${n}`})),...this.attributes.filter((e=>e.isInterpolable)).map((i=>{const{attributeName:r}=i,s=(i.components||[""]).map((e=>{const i=this.attributeComponentIndices[`${r}${e}Delta`],s=Math.floor(i/this.dataChannelCount),a=["r","g","b","a"][i%this.dataChannelCount];return`${t}[${s}].${a}`})).join(", "),a=i.components?`vec${i.components.length}(${s})`:s;return`#define ${e}${r}Delta() ${a}`}))].join("\n")}generateRebaseFragmentGLSL(e="previousTexelValues",t="targetTexelValues",i="texelIndex",r="rebaseTs"){const s={};for(const i of this.attributes){const{attributeName:n}=i;for(const o of i.components||[""]){const l=`${n}${o}`,h=this.attributeComponentIndices[l],c=Math.floor(h/this.dataChannelCount),u=a[h%this.dataChannelCount],d=`${e}[${c}].${u}`,p=`${t}[${c}].${u}`;if(c in s||(s[c]={}),i.isTimestamp){const e=`${r};`;s[c][u]=e}else if(i.isInterpolable){const t=`${l}Delta`,i=this.attributeComponentIndices[t],n=Math.floor(i/this.dataChannelCount),o=a[i%this.dataChannelCount];n in s||(s[n]={});const h=`${e}[${n}].${o}`;s[c][u]=`computeValueAtTime(${d}, ${h}, ${p}, ${r});`,s[n][o]=`computeDeltaAtTime(${d}, ${h}, ${p}, ${r});`}else s[c][u]=`computeThresholdValue(${d}, ${p}, ${r});`}}const n=[];for(let e=0;e<this.texelsPerSwatch;e++){const t=s[e];n.push(`if (${i} < ${e}.5) {`);for(let e=0;e<this.dataChannelCount;e++){const i=a[e];i in t&&n.push(`  gl_FragColor.${i} = ${t[i]}`)}n.push("  return;"),n.push("}")}return n.join("\n")}generateInstanceSwatchUvValues(){const e=new Float32Array(2*this.totalSwatches);for(let t=0;t<this.textureHeight;t++)for(let i=0;i<this.swatchesPerRow;i++){const r=2*(t*this.swatchesPerRow+i);e[r]=i/this.swatchesPerRow,e[r+1]=t/this.textureHeight}return e}}function l(e,...t){const i=[];for(let r=0;r<t.length;r++)i.push(e[r],`${t[r]}`);return i.push(e[e.length-1]),i.join("")}const h=["float","vec2","vec3","vec4"];function c(){return l`
float range(float x, float y, float a) {
  return (a - x) / (y - x);
}
`}function u(){return l`
float cubicEaseInOut(float t) {
  return t < 0.5 ? 4.0 * t * t * t :
    4.0 * (t - 1.0) * (t - 1.0) * (t - 1.0) + 1.0;
}
`}function d(e="t",t="varyingT"){return h.map((i=>l`
${i} computeCurrentValue(
    ${i} startingValue,
    ${i} startingVelocity,
    ${i} targetValue) {
  ${i} currentValue = mix(startingValue, targetValue, ${t});
  ${i} projectedValue = startingVelocity *
    (targetTransitionTimeMs() - previousTransitionTimeMs());
  return currentValue + projectedValue *
    ${e} * (1. - ${e}) * (1. - ${e}) * (1. - ${e});
}
  `)).join("\n")}function p(){return l`
/**
 * @param positionWorld The position of the sprite in world coords.
 * @param size Size of the sprite in world coordinates.
 * @param positionRelative Offset position relative to vert coords.
 * @param positionPixel Offset position in screen pixels.
 * @param vertCoords Local coordinates for this vertex.
 * @param viewMatrix Matrix to project world coords into view space (pixels).
 */
vec2 computeViewVertexPosition(
    vec2 positionWorld,
    vec2 size,
    vec2 positionRelative,
    vec2 positionPixel,
    vec2 vertCoords,
    mat3 viewMatrix
) {
  vec2 vertexPositionWorld =
    positionWorld + size * (positionRelative + vertCoords);
  vec2 viewVertexPosition =
    (viewMatrix * vec3(vertexPositionWorld, 1.)).xy + positionPixel * 4.;
  return viewVertexPosition;
}
`}function m(){return l`
/**
 *
 * @param sizeWorld Size of the sprite in world coordinates.
 * @param sizePixel Offset size of the sprite in pixels.
 * @param geometricZoom The geometric zoom size modifier.
 * @param viewMatrixScale XY scale (world coords to pixels), and ZW inverse.
 * @param maxSizePixel Maximum allowed size in pixels.
 * @param minSizePixel Minimum allowed size in pixels.
 */
vec2 computeSize(
  vec2 sizeWorld,
  vec2 sizePixel,
  vec2 geometricZoom,
  vec4 viewMatrixScale,
  vec2 maxSizePixel,
  vec2 minSizePixel
) {
  // Combine scale with geometric zoom effect.
  vec2 zoomScale = exp(log(viewMatrixScale.xy) * (1. - geometricZoom));

  // Project the size in world coordinates to pixels to apply min/max.
  vec2 projectedSizePixel = (sizeWorld * zoomScale + sizePixel * 4.);

  // Inital computed size in world coordinates is based on projected pixel size.
  vec2 computedSize = projectedSizePixel * viewMatrixScale.zw;

  // TODO(jimbo): Add border width to size if positioned externally.

  // Compute whether max and min size components are positive, in parallel.
  // XY contains results for max, ZW contains results for min.
  bvec4 isPositive = greaterThan(vec4(maxSizePixel, minSizePixel), vec4(0.));

  // Apply maximums if set.
  bvec2 gtMax = greaterThan(projectedSizePixel, maxSizePixel);
  if (isPositive.x && gtMax.x) {
    computedSize.x = maxSizePixel.x * viewMatrixScale.z;
  }
  if (isPositive.y && gtMax.y) {
    computedSize.y = maxSizePixel.y * viewMatrixScale.w;
  }

  // Apply minimums if set.
  bvec2 ltMin = lessThan(projectedSizePixel, minSizePixel);
  if (isPositive.z && ltMin.x) {
    computedSize.x = minSizePixel.x * viewMatrixScale.z;
  }
  if (isPositive.w && ltMin.y) {
    computedSize.y = minSizePixel.y * viewMatrixScale.w;
  }

  return computedSize;
}
`}function f(){return l`
vec4 computeCurrentSizePixelAndWorld() {
  return computeCurrentValue(
    vec4(
      previousSizePixel(),
      previousSizeWorld()),
    vec4(
      previousSizePixelDelta(),
      previousSizeWorldDelta()),
    vec4(
      targetSizePixel(),
      targetSizeWorld())
  );
}
`}function g(){return l`
vec4 computeCurrentMaxAndMinSizePixel() {
  return computeCurrentValue(
    vec4(
      previousMaxSizePixel(),
      previousMinSizePixel()
    ),
    vec4(
      previousMaxSizePixelDelta(),
      previousMinSizePixelDelta()
    ),
    vec4(
      targetMaxSizePixel(),
      targetMinSizePixel()
    )
  ) * 4.;
}
`}function x(e){return l`
precision lowp float;

/**
 * Current uniform timestamp for interpolating.
 */
uniform float ts;

/**
 * Incremental clip-space Z for stacking sprites based on their instanceIndex.
 * This ensures that partial-opacity pixels of stacked sprites will be
 * alpha-blended. Without this, occluded sprites' pixels may not blend.
 */
uniform float instanceZ;

/**
 * View and projection matrices for converting from world space to clip space.
 */
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

/**
 * Scale includes the X and Y dimensions of the viewMatrix, and their inverses
 * in the WZ components.
 */
uniform vec4 viewMatrixScale;

/**
 * Data textures holding the previous and target Sprite instance
 * attributes. The instantaneous value for each attribute is determined by
 * interpolating between the previous and target according to the ts uniform.
 */
uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

/**
 * Per-vertex coordinates for the quad into which the sprite will be rendered.
 * XY contain the local cartesian coordinates for a unit square centered at the
 * origin. The ZW coordinates contain the y-flipped UV coordinates for orienting
 * the square against texture atlases.
 *
 *   vertexCoordinates: [
 *     [-0.5, -0.5, 0, 1],
 *     [0.5, -0.5, 1, 1],
 *     [-0.5, 0.5, 0, 0],
 *     [0.5, 0.5, 1, 0],
 *   ],
 *
 */
attribute vec4 vertexCoordinates;

/**
 * Instanced, per-sprite index and UV coordinates of the sprite's data swatch.
 */
attribute float instanceIndex;
attribute vec2 instanceSwatchUv;

/**
 * Varying time value, eased using cubic-in-out between the previous and target
 * timestamps for this Sprite.
 */
varying float varyingT;

/**
 * Interpolated vertexCoordinates for fragment shader.
 */
varying vec4 varyingVertexCoordinates;

/**
 * Threshold distance values to consider the pixel outside the shape (X) or
 * inside the shape (Y). Values between constitue the borde.
 */
varying vec2 varyingBorderThresholds;

/**
 * Aspect ratio of the sprite's renderable area (XY) and their inverses (ZW).
 * One component of each pair will be 1. For the XY pair, the other component
 * be be greater than 1. and for the inverse pair it will be smaller.
 *
 * For example, a rectangle that's twice as wide as it is tall would have
 * varyingAspectRatio equal to vec4(2., 1., .5, 1.).
 */
varying vec4 varyingAspectRatio;

/**
 * Color attributes used by fragment shader.
 */
varying vec4 varyingBorderColor;
varying vec4 varyingFillColor;

/**
 * Shape attributes used by fragment shader.
 */
varying float varyingPreviousSides;
varying float varyingTargetSides;
varying vec4 varyingPreviousShapeTexture;
varying vec4 varyingTargetShapeTexture;

// Import utility shader functions.
${c()}
${u()}

// These arrays are filled in by code generated by the AttributeMapper.
vec4 previousTexelValues[${e.texelsPerSwatch}];
vec4 targetTexelValues[${e.texelsPerSwatch}];

/**
 * Read data texel values into the previous and target arrays.
 */
void readTexels() {
    ${e.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","instanceSwatchUv")}
    ${e.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","instanceSwatchUv")}
}

// Dynamically generate #DEFINE statements to access texel attributes by name.
// These look like method invocations elsewhere in the code. For example, the
// define "targetTransitionTimeMs()" extracts the float value
// targetTexelValues[0].r.
${e.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${e.generateAttributeDefinesGLSL("target","targetTexelValues")}

/**
 * Local, non-eased, normalized time value between 0 and 1, computed between the
 * previous and target timestamp according to the uniform ts.
 */
float t;

${d()}

/**
 * Precomputed constant value for converting colors in the 0-255 RGB range to
 * the GL standard 0-1 range. (1 / 255 = 0.00392156862745098)
 */
const vec4 GL_COLOR = vec4(vec3(0.00392156862745098), 1.);

/**
 * Function to compute all the varying values needed by the fragment shader.
 */
void setupVaryings() {
  // Clamp and range t value within previous and target timestamps.
  t =
    ts >= targetTransitionTimeMs() ? 1. :
    ts <= previousTransitionTimeMs() ? 0. :
    clamp(range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
        0., 1.);

  // Compute eased varyingT.
  varyingT = cubicEaseInOut(t);

  // Copy and interpolate vertex coordinate values.
  varyingVertexCoordinates = vertexCoordinates;

  // Copy previous and target shape attributes.
  varyingPreviousSides = previousSides();
  varyingPreviousShapeTexture = previousShapeTexture();
  varyingTargetSides = targetSides();
  varyingTargetShapeTexture = targetShapeTexture();

  // Compute color attributes.
  varyingBorderColor = computeCurrentValue(
    previousBorderColor(),
    previousBorderColorDelta(),
    targetBorderColor()) * GL_COLOR;
  varyingFillColor = computeCurrentValue(
    previousFillColor(),
    previousFillColorDelta(),
    targetFillColor()) * GL_COLOR;
}

${l`
/**
 * @param size The size of the sprite.
 * @return The aspect ratio (XY) and the inverse of the aspect ratio (ZW).
 */
vec4 computeAspectRatio(vec2 size) {
  vec2 ar = size / min(size.x, size.y);
  return vec4(ar, 1. / ar);
}
`}
${g()}
${f()}
${m()}
${p()}

void main () {

  // Read data values from previous and target data textures.
  readTexels();

  // Setup varying values used both here and by the fragment shader.
  setupVaryings();

  // Compute current size component values by interpolation (parallelized).
  vec4 currentSizePixelAndWorld = computeCurrentSizePixelAndWorld();
  vec2 currentSizePixel = currentSizePixelAndWorld.xy;
  vec2 currentSizeWorld = currentSizePixelAndWorld.zw;

  vec2 currentGeometricZoom = computeCurrentValue(
      previousGeometricZoom(),
      previousGeometricZoomDelta(),
      targetGeometricZoom()
  );

  vec4 currentMaxAndMinSizePixel = computeCurrentMaxAndMinSizePixel();
  vec2 currentMaxSizePixel = currentMaxAndMinSizePixel.xy;
  vec2 currentMinSizePixel = currentMaxAndMinSizePixel.zw;

  // Compute the current size of the sprite in world units, including the effect
  // of geometric zoom and applying min and max pixel sizes.
  vec2 computedSize = computeSize(
    currentSizeWorld,
    currentSizePixel,
    currentGeometricZoom,
    viewMatrixScale,
    currentMaxSizePixel,
    currentMinSizePixel
  );

  // Compute border attributes in parallel.
  vec3 borderProperties = computeCurrentValue(
      vec3(
        previousBorderRadiusWorld(),
        previousBorderRadiusPixel(),
        previousBorderPlacement()),
      vec3(
        previousBorderRadiusWorldDelta(),
        previousBorderRadiusPixelDelta(),
        previousBorderPlacementDelta()),
      vec3(
        targetBorderRadiusWorld(),
        targetBorderRadiusPixel(),
        targetBorderPlacement())
  );

  // The fragment shader needs to know the threshold signed distances that
  // indicate whether each pixel is inside the shape, in the boreder, or outside
  // of the shape.
  vec2 projectedSizePixel = computedSize.xy * viewMatrixScale.xy;
  float edgeDistance = borderProperties.x +
    borderProperties.y * 8. / min(projectedSizePixel.x, projectedSizePixel.y);
  varyingBorderThresholds =
    vec2(0., edgeDistance) + mix(0., -edgeDistance, borderProperties.z);

  // Compute the sprite's aspect ratio and the inverse.
  varyingAspectRatio = computeAspectRatio(computedSize);

  // Compute the current position component attributes.
  vec2 currentPositionPixel = computeCurrentValue(
      previousPositionPixel(),
      previousPositionPixelDelta(),
      targetPositionPixel());

  vec2 currentPositionWorld = computeCurrentValue(
      previousPositionWorld(),
      previousPositionWorldDelta(),
      targetPositionWorld());

  vec2 currentPositionRelative = computeCurrentValue(
      previousPositionRelative(),
      previousPositionRelativeDelta(),
      targetPositionRelative());

  // Project the world position into pixel space, then add the pixel component.
  vec2 viewVertexPosition = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      vertexCoordinates.xy,
      viewMatrix
  );

  // Project the pixel space coordinate into clip space.
  vec2 clipVertexPosition =
    (projectionMatrix * vec3(viewVertexPosition, 1.)).xy;

  // Align Z axis clip-space coordinate (perpendicular to screen) with instance
  // index for blending stacked sprites.
  gl_Position = vec4(clipVertexPosition, -instanceIndex * instanceZ, 1.);
}
`}function v(e,t){return l`
precision lowp float;

uniform float ts;

/**
 * Screen pixel coordinates for performing the hit test. The XY channels contain
 * the screen x and y coordinates respectively. The ZW channels hold the width
 * and height of the bounding box of interest. Currently those are ignored.
 */
uniform vec4 hitTestCoordinates;

uniform mat3 viewMatrix;

/**
 * Scale includes the X and Y dimensions of the viewMatrix, and their inverses
 * in the WZ components.
 */
uniform vec4 viewMatrixScale;

uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

attribute vec2 vertexCoordinates;

attribute vec2 instanceSwatchUv;
attribute vec2 instanceHitTestUv;

#define TEXELS_PER_SWATCH ${e.texelsPerSwatch}.
#define TEXTURE_WIDTH ${e.textureWidth}.
#define TEXTURE_HEIGHT ${e.textureHeight}.

// The result of the hit test, written to the data texel by the fragment shader.
varying float varyingHitTestResult;

vec4 previousTexelValues[${t.texelsPerSwatch}];
vec4 targetTexelValues[${t.texelsPerSwatch}];

${t.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${t.generateAttributeDefinesGLSL("target","targetTexelValues")}

float rangeT;
float easeT;

// Import utility shader functions.
${c()}
${u()}
${d("rangeT","easeT")}
${g()}
${f()}
${m()}
${p()}

void readInputTexels() {
${t.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","instanceSwatchUv")}
${t.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","instanceSwatchUv")}
}

const vec2 swatchSize =
  vec2(TEXELS_PER_SWATCH / TEXTURE_WIDTH, 1. / TEXTURE_HEIGHT);

void main () {
  readInputTexels();

  // Compute time variables.
  rangeT = clamp(
      range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
      0., 1.);
  easeT = cubicEaseInOut(rangeT);

  // Compute current size component values by interpolation (parallelized).
  vec4 currentSizePixelAndWorld = computeCurrentSizePixelAndWorld();
  vec2 currentSizePixel = currentSizePixelAndWorld.xy;
  vec2 currentSizeWorld = currentSizePixelAndWorld.zw;

  vec2 currentGeometricZoom = computeCurrentValue(
      previousGeometricZoom(),
      previousGeometricZoomDelta(),
      targetGeometricZoom()
  );

  vec4 currentMaxAndMinSizePixel = computeCurrentMaxAndMinSizePixel();
  vec2 currentMaxSizePixel = currentMaxAndMinSizePixel.xy;
  vec2 currentMinSizePixel = currentMaxAndMinSizePixel.zw;

  // Compute the current size of the sprite in world units, including the effect
  // of geometric zoom and applying min and max pixel sizes.
  vec2 computedSize = computeSize(
    currentSizeWorld,
    currentSizePixel,
    currentGeometricZoom,
    viewMatrixScale,
    currentMaxSizePixel,
    currentMinSizePixel
  );

  // Compute the current position component attributes.
  vec2 currentPositionPixel = computeCurrentValue(
      previousPositionPixel(),
      previousPositionPixelDelta(),
      targetPositionPixel());

  vec2 currentPositionWorld = computeCurrentValue(
      previousPositionWorld(),
      previousPositionWorldDelta(),
      targetPositionWorld());

  vec2 currentPositionRelative = computeCurrentValue(
      previousPositionRelative(),
      previousPositionRelativeDelta(),
      targetPositionRelative());

  // Project the world position into pixel space for the bottom left and top
  // right corners of the sprite's quad.
  vec2 bottomLeft = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      vec2(-.5, -.5),
      viewMatrix
  ) * .25;
  vec2 topRight = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      vec2(.5, .5),
      viewMatrix
  ) * .25;

  // Test whether the coordinates of interest are within the sprite quad's
  // bounding box.
  // TODO (jimbo): Use ZW components to test for area of interest.
  varyingHitTestResult =
    bottomLeft.x < hitTestCoordinates.x &&
    bottomLeft.y > hitTestCoordinates.y &&
    topRight.x > hitTestCoordinates.x &&
    topRight.y < hitTestCoordinates.y ? 1. : 0.;

  vec2 swatchUv =
    instanceHitTestUv + (vertexCoordinates.xy + .5) * swatchSize;

  // Position the verts to write into the appropriate data texel.
  gl_Position = vec4(2. * swatchUv - 1., 0., 1.);
}
`}function w(e){return l`
precision lowp float;

uniform float ts;

uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

varying float varyingTexelIndex;
varying vec2 varyingRebaseUv;

vec4 previousTexelValues[${e.texelsPerSwatch}];
vec4 targetTexelValues[${e.texelsPerSwatch}];

${e.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${e.generateAttributeDefinesGLSL("target","targetTexelValues")}

// Import utility shader functions.
${c()}
${u()}

float computeValueAtTime(
    float startingValue,
    float startingDelta,
    float targetValue,
    float ts) {
  float rangeT =
    ts >= targetTransitionTimeMs() ? 1. :
    ts <= previousTransitionTimeMs() ? 0. :
    clamp(
        range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
        0., 1.);
  float easeT = cubicEaseInOut(rangeT);

  float currentValue = mix(startingValue, targetValue, easeT);
  float projectedValue = startingDelta *
    (targetTransitionTimeMs() - previousTransitionTimeMs());

  return currentValue + projectedValue * rangeT * pow(1. - rangeT, 3.);
}

// DELTA_MS is the duration in milliseconds to use when estimating the
// 'instantaneous' change in a value. INV_DELTA_MS is its inverse.
#define DELTA_MS 1.
#define INV_DELTA_MS 1.

float computeDeltaAtTime(
    float startingValue,
    float startingDelta,
    float targetValue,
    float ts
) {
  if (ts >= targetTransitionTimeMs()) {
    return 0.;
  }
  if (ts <= previousTransitionTimeMs()) {
    return startingDelta;
  }
  return (
      computeValueAtTime(
          startingValue, startingDelta, targetValue, ts + DELTA_MS) -
      computeValueAtTime(
          startingValue, startingDelta, targetValue, ts)
      ) * INV_DELTA_MS;
}

float computeThresholdValue(
    float previousValue,
    float targetValue,
    float rebaseTs
) {
  float mid = mix(previousTransitionTimeMs(), targetTransitionTimeMs(), .5);
  return rebaseTs < mid ? previousValue : targetValue;
}

void readInputTexels() {
${e.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","varyingRebaseUv")}
${e.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","varyingRebaseUv")}
}

void setOutputTexel() {
  float rebaseTs = ts;
  ${e.generateRebaseFragmentGLSL("previousTexelValues","targetTexelValues","varyingTexelIndex","rebaseTs")}
}

void main () {
  readInputTexels();
  setOutputTexel();
}
`}function b(e){return l`
precision lowp float;

attribute vec2 vertexCoordinates;

attribute vec2 instanceRebaseUv;

#define TEXELS_PER_SWATCH ${e.texelsPerSwatch}.
#define TEXTURE_WIDTH ${e.textureWidth}.
#define TEXTURE_HEIGHT ${e.textureHeight}.

varying vec2 varyingRebaseUv;
varying float varyingTexelIndex;

const vec2 swatchSize =
  vec2(TEXELS_PER_SWATCH / TEXTURE_WIDTH, 1. / TEXTURE_HEIGHT);

void main () {
  varyingRebaseUv = instanceRebaseUv;
  varyingTexelIndex = (vertexCoordinates.x + .5) * TEXELS_PER_SWATCH - .5;
  vec2 swatchUv = instanceRebaseUv + (vertexCoordinates.xy + .5) * swatchSize;
  gl_Position = vec4(2. * swatchUv - 1., 0., 1.);
}
`}const T=Object.freeze({requestAnimationFrame:window.requestAnimationFrame.bind(window),cancelAnimationFrame:window.cancelAnimationFrame.bind(window),setTimeout:(e,t=0,...i)=>window.setTimeout(e,t,...i),clearTimeout:window.clearTimeout.bind(window),now:Date.now.bind(Date)}),y=1e20;class S{constructor(e=24,t=3,i=8,r=.25,s="sans-serif",a="normal"){this.fontSize=e,this.buffer=t,this.radius=i,this.cutoff=r,this.fontFamily=s,this.fontWeight=a;const n=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=n,this.ctx=this.canvas.getContext("2d"),this.ctx.font=this.fontWeight+" "+this.fontSize+"px "+this.fontFamily,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(n*n),this.gridInner=new Float64Array(n*n),this.f=new Float64Array(n),this.z=new Float64Array(n+1),this.v=new Uint16Array(n),this.middle=Math.round(n/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}draw(e){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(e,this.buffer,this.middle);const t=this.ctx.getImageData(0,0,this.size,this.size);return function({imgData:e,size:t,radius:i,cutoff:r,gridOuter:s,gridInner:a,f:n,v:o,z:l}){const h=new Uint8ClampedArray(t*t);for(let i=0;i<t*t;i++){const t=e.data[4*i+3]/255;s[i]=1===t?0:0===t?y:Math.pow(Math.max(0,.5-t),2),a[i]=1===t?y:0===t?0:Math.pow(Math.max(0,t-.5),2)}P(s,t,t,n,o,l),P(a,t,t,n,o,l);for(let e=0;e<t*t;e++){const t=Math.sqrt(s[e])-Math.sqrt(a[e]);h[e]=Math.round(255-255*(t/i+r))}return h}(Object.assign(Object.assign({},this),{imgData:t}))}}function P(e,t,i,r,s,a){R(e,t,i,r,s,a),C(e,t,i,r,s,a)}function C(e,t,i,r,s,a){for(let n=0;n<i;n++)k(e,n*t,1,t,r,s,a)}function R(e,t,i,r,s,a){for(let n=0;n<t;n++)k(e,n,t,i,r,s,a)}function k(e,t,i,r,s,a,n){let o,l,h,c;for(a[0]=0,n[0]=-y,n[1]=y,o=0;o<r;o++)s[o]=e[t+o*i];for(o=1,l=0,h=0;o<r;o++){do{c=a[l],h=(s[o]-s[c]+o*o-c*c)/(o-c)/2}while(h<=n[l]&&--l>-1);l++,a[l]=o,n[l]=h,n[l+1]=y}for(o=0,l=0;o<r;o++){for(;n[l+1]<o;)l++;c=a[l],e[t+o*i]=s[c]+(o-c)*(o-c)}}const z=Object.freeze({maxTextureSize:2048,fontSize:32,buffer:Math.ceil(8),radius:32,cutoff:.5,fontFamily:"monospace",fontWeight:"normal"});class N{constructor(e=z){this.glyphToCoordinates=new Map;const t=Object.assign({},z,e||{});this.maxTextureSize=t.maxTextureSize,this.tinySDF=new S(t.fontSize,t.buffer,t.radius,t.cutoff,t.fontFamily,t.fontWeight),this.glyphSize=this.tinySDF.size,this.glyphsPerRow=Math.floor(this.maxTextureSize/this.glyphSize),this.glyphCapacity=this.glyphsPerRow*this.glyphsPerRow,this.textureSize=this.glyphsPerRow*this.glyphSize,this.textureData=new Float32Array(this.textureSize*this.textureSize)}hasGlyph(e){return this.glyphToCoordinates.has(e)}getGlyph(e){return this.glyphToCoordinates.get(e)}addGlyph(e){if(this.hasGlyph(e))return this.getGlyph(e);const t=this.glyphToCoordinates.size;if(t>=this.glyphCapacity)throw new Error("Cannot add glyph, already at capacity.");const i=Math.floor(t/this.glyphsPerRow),r=t%this.glyphsPerRow,s=i*this.glyphSize*this.textureSize+r*this.glyphSize,{canvas:a,ctx:n,size:o,buffer:l,middle:h,radius:c,cutoff:u}=this.tinySDF;n.clearRect(0,0,o,o),n.fillText(e,l,h);const d=function(e,t,i=.5){const{width:r,height:s}=e,a=e.getContext("2d").getImageData(0,0,r,s),n=new Float64Array(r*s),o=new Float64Array(r*s),l=new Float64Array(r*s),h=new Float64Array(r*s),c=new Float64Array(r*s),u=new Float64Array(r*s),d=new Float64Array(r),p=new Float64Array(r+1),m=new Uint16Array(r);for(let e=0;e<r*s;e++){const t=a.data[4*e+3]/255;c[e]=l[e]=n[e]=1===t?0:0===t?y:Math.pow(Math.max(0,.5-t),2),u[e]=h[e]=o[e]=1===t?y:0===t?0:Math.pow(Math.max(0,t-.5),2)}P(c,r,s,d,m,p),P(u,r,s,d,m,p),C(n,r,s,d,m,p),C(o,r,s,d,m,p),R(l,r,s,d,m,p),R(h,r,s,d,m,p);const f=new Float32Array(r*s*3);for(let e=0;e<r*s;e++)f[3*e]=Math.max(0,1-((Math.sqrt(n[e])-Math.sqrt(o[e]))/t+i)),f[3*e+1]=Math.max(0,1-((Math.sqrt(l[e])-Math.sqrt(h[e]))/t+i)),f[3*e+2]=1-((Math.sqrt(c[e])-Math.sqrt(u[e]))/t+i);return f}(a,c,u);for(let e=0;e<this.glyphSize;e++)for(let t=0;t<this.glyphSize;t++){const i=3*(e*this.glyphSize+t)+2,r=s+e*this.textureSize+t;this.textureData[r]=d[i]}const p={u:r/this.glyphsPerRow,v:i/this.glyphsPerRow,width:this.glyphSize/this.textureSize,height:this.glyphSize/this.textureSize};return this.glyphToCoordinates.set(e,p),p}get glyphs(){return[...this.glyphToCoordinates.keys()]}}const M=Object.freeze({container:document.body,defaultTransitionTimeMs:250,glyphs:"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}",desiredSpriteCapacity:1e6,timingFunctions:T,glyphMapper:z});class W{constructor(e){this.coordinator=e,this.xValue=0,this.yValue=0}get x(){return this.xValue}set x(e){this.xValue=e,this.coordinator.queueDraw()}get y(){return this.yValue}set y(e){this.yValue=e,this.coordinator.queueDraw()}}const V=Symbol("internalProperties"),I=Symbol("dataView"),A=Symbol("sceneInternal");class E{constructor(e){this[I]=e}get TransitionTimeMs(){return this[I][0]}set TransitionTimeMs(e){if(isNaN(e))throw new RangeError("TransitionTimeMs cannot be NaN.");this[I][0]=e}get PositionWorldX(){return this[I][1]}set PositionWorldX(e){if(isNaN(e))throw new RangeError("PositionWorldX cannot be NaN.");this[I][1]=e}get PositionWorldY(){return this[I][2]}set PositionWorldY(e){if(isNaN(e))throw new RangeError("PositionWorldY cannot be NaN.");this[I][2]=e}get SizeWorldWidth(){return this[I][3]}set SizeWorldWidth(e){if(isNaN(e))throw new RangeError("SizeWorldWidth cannot be NaN.");this[I][3]=e}get SizeWorldHeight(){return this[I][4]}set SizeWorldHeight(e){if(isNaN(e))throw new RangeError("SizeWorldHeight cannot be NaN.");this[I][4]=e}get GeometricZoomX(){return this[I][5]}set GeometricZoomX(e){if(isNaN(e))throw new RangeError("GeometricZoomX cannot be NaN.");this[I][5]=e}get GeometricZoomY(){return this[I][6]}set GeometricZoomY(e){if(isNaN(e))throw new RangeError("GeometricZoomY cannot be NaN.");this[I][6]=e}get PositionPixelX(){return this[I][7]}set PositionPixelX(e){if(isNaN(e))throw new RangeError("PositionPixelX cannot be NaN.");this[I][7]=e}get PositionPixelY(){return this[I][8]}set PositionPixelY(e){if(isNaN(e))throw new RangeError("PositionPixelY cannot be NaN.");this[I][8]=e}get SizePixelWidth(){return this[I][9]}set SizePixelWidth(e){if(isNaN(e))throw new RangeError("SizePixelWidth cannot be NaN.");this[I][9]=e}get SizePixelHeight(){return this[I][10]}set SizePixelHeight(e){if(isNaN(e))throw new RangeError("SizePixelHeight cannot be NaN.");this[I][10]=e}get MaxSizePixelWidth(){return this[I][11]}set MaxSizePixelWidth(e){if(isNaN(e))throw new RangeError("MaxSizePixelWidth cannot be NaN.");this[I][11]=e}get MaxSizePixelHeight(){return this[I][12]}set MaxSizePixelHeight(e){if(isNaN(e))throw new RangeError("MaxSizePixelHeight cannot be NaN.");this[I][12]=e}get MinSizePixelWidth(){return this[I][13]}set MinSizePixelWidth(e){if(isNaN(e))throw new RangeError("MinSizePixelWidth cannot be NaN.");this[I][13]=e}get MinSizePixelHeight(){return this[I][14]}set MinSizePixelHeight(e){if(isNaN(e))throw new RangeError("MinSizePixelHeight cannot be NaN.");this[I][14]=e}get PositionRelativeX(){return this[I][15]}set PositionRelativeX(e){if(isNaN(e))throw new RangeError("PositionRelativeX cannot be NaN.");this[I][15]=e}get PositionRelativeY(){return this[I][16]}set PositionRelativeY(e){if(isNaN(e))throw new RangeError("PositionRelativeY cannot be NaN.");this[I][16]=e}get Sides(){return this[I][17]}set Sides(e){if(isNaN(e))throw new RangeError("Sides cannot be NaN.");this[I][17]=e}get ShapeTextureU(){return this[I][18]}set ShapeTextureU(e){if(isNaN(e))throw new RangeError("ShapeTextureU cannot be NaN.");this[I][18]=e}get ShapeTextureV(){return this[I][19]}set ShapeTextureV(e){if(isNaN(e))throw new RangeError("ShapeTextureV cannot be NaN.");this[I][19]=e}get ShapeTextureWidth(){return this[I][20]}set ShapeTextureWidth(e){if(isNaN(e))throw new RangeError("ShapeTextureWidth cannot be NaN.");this[I][20]=e}get ShapeTextureHeight(){return this[I][21]}set ShapeTextureHeight(e){if(isNaN(e))throw new RangeError("ShapeTextureHeight cannot be NaN.");this[I][21]=e}get BorderRadiusWorld(){return this[I][22]}set BorderRadiusWorld(e){if(isNaN(e))throw new RangeError("BorderRadiusWorld cannot be NaN.");this[I][22]=e}get BorderRadiusPixel(){return this[I][23]}set BorderRadiusPixel(e){if(isNaN(e))throw new RangeError("BorderRadiusPixel cannot be NaN.");this[I][23]=e}get BorderPlacement(){return this[I][24]}set BorderPlacement(e){if(isNaN(e))throw new RangeError("BorderPlacement cannot be NaN.");this[I][24]=e}get BorderColorR(){return this[I][25]}set BorderColorR(e){if(isNaN(e))throw new RangeError("BorderColorR cannot be NaN.");this[I][25]=e}get BorderColorG(){return this[I][26]}set BorderColorG(e){if(isNaN(e))throw new RangeError("BorderColorG cannot be NaN.");this[I][26]=e}get BorderColorB(){return this[I][27]}set BorderColorB(e){if(isNaN(e))throw new RangeError("BorderColorB cannot be NaN.");this[I][27]=e}get BorderColorOpacity(){return this[I][28]}set BorderColorOpacity(e){if(isNaN(e))throw new RangeError("BorderColorOpacity cannot be NaN.");this[I][28]=e}get FillBlend(){return this[I][29]}set FillBlend(e){if(isNaN(e))throw new RangeError("FillBlend cannot be NaN.");this[I][29]=e}get FillColorR(){return this[I][30]}set FillColorR(e){if(isNaN(e))throw new RangeError("FillColorR cannot be NaN.");this[I][30]=e}get FillColorG(){return this[I][31]}set FillColorG(e){if(isNaN(e))throw new RangeError("FillColorG cannot be NaN.");this[I][31]=e}get FillColorB(){return this[I][32]}set FillColorB(e){if(isNaN(e))throw new RangeError("FillColorB cannot be NaN.");this[I][32]=e}get FillColorOpacity(){return this[I][33]}set FillColorOpacity(e){if(isNaN(e))throw new RangeError("FillColorOpacity cannot be NaN.");this[I][33]=e}get FillTextureU(){return this[I][34]}set FillTextureU(e){if(isNaN(e))throw new RangeError("FillTextureU cannot be NaN.");this[I][34]=e}get FillTextureV(){return this[I][35]}set FillTextureV(e){if(isNaN(e))throw new RangeError("FillTextureV cannot be NaN.");this[I][35]=e}get FillTextureWidth(){return this[I][36]}set FillTextureWidth(e){if(isNaN(e))throw new RangeError("FillTextureWidth cannot be NaN.");this[I][36]=e}get FillTextureHeight(){return this[I][37]}set FillTextureHeight(e){if(isNaN(e))throw new RangeError("FillTextureHeight cannot be NaN.");this[I][37]=e}set PositionWorld(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionWorldX=e[0],t=!0),"1"in e&&(this.PositionWorldY=e[1],t=!0),!t)throw new TypeError("No PositionWorld component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("x"in e&&(this.PositionWorldX=e.x,t=!0),"y"in e&&(this.PositionWorldY=e.y,t=!0),!t)throw new TypeError("No PositionWorld component key values were found.")}}}set SizeWorld(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.SizeWorldWidth=e[0],t=!0),"1"in e&&(this.SizeWorldHeight=e[1],t=!0),!t)throw new TypeError("No SizeWorld component index values were found.")}else if("object"!=typeof e)this.SizeWorldWidth=e,this.SizeWorldHeight=e;else{let t=!1;if("width"in e&&(this.SizeWorldWidth=e.width,t=!0),"height"in e&&(this.SizeWorldHeight=e.height,t=!0),!t)throw new TypeError("No SizeWorld component key values were found.")}}set GeometricZoom(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.GeometricZoomX=e[0],t=!0),"1"in e&&(this.GeometricZoomY=e[1],t=!0),!t)throw new TypeError("No GeometricZoom component index values were found.")}else if("object"!=typeof e)this.GeometricZoomX=e,this.GeometricZoomY=e;else{let t=!1;if("x"in e&&(this.GeometricZoomX=e.x,t=!0),"y"in e&&(this.GeometricZoomY=e.y,t=!0),!t)throw new TypeError("No GeometricZoom component key values were found.")}}set PositionPixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionPixelX=e[0],t=!0),"1"in e&&(this.PositionPixelY=e[1],t=!0),!t)throw new TypeError("No PositionPixel component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("x"in e&&(this.PositionPixelX=e.x,t=!0),"y"in e&&(this.PositionPixelY=e.y,t=!0),!t)throw new TypeError("No PositionPixel component key values were found.")}}}set SizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.SizePixelWidth=e[0],t=!0),"1"in e&&(this.SizePixelHeight=e[1],t=!0),!t)throw new TypeError("No SizePixel component index values were found.")}else if("object"!=typeof e)this.SizePixelWidth=e,this.SizePixelHeight=e;else{let t=!1;if("width"in e&&(this.SizePixelWidth=e.width,t=!0),"height"in e&&(this.SizePixelHeight=e.height,t=!0),!t)throw new TypeError("No SizePixel component key values were found.")}}set MaxSizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.MaxSizePixelWidth=e[0],t=!0),"1"in e&&(this.MaxSizePixelHeight=e[1],t=!0),!t)throw new TypeError("No MaxSizePixel component index values were found.")}else if("object"!=typeof e)this.MaxSizePixelWidth=e,this.MaxSizePixelHeight=e;else{let t=!1;if("width"in e&&(this.MaxSizePixelWidth=e.width,t=!0),"height"in e&&(this.MaxSizePixelHeight=e.height,t=!0),!t)throw new TypeError("No MaxSizePixel component key values were found.")}}set MinSizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.MinSizePixelWidth=e[0],t=!0),"1"in e&&(this.MinSizePixelHeight=e[1],t=!0),!t)throw new TypeError("No MinSizePixel component index values were found.")}else if("object"!=typeof e)this.MinSizePixelWidth=e,this.MinSizePixelHeight=e;else{let t=!1;if("width"in e&&(this.MinSizePixelWidth=e.width,t=!0),"height"in e&&(this.MinSizePixelHeight=e.height,t=!0),!t)throw new TypeError("No MinSizePixel component key values were found.")}}set PositionRelative(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionRelativeX=e[0],t=!0),"1"in e&&(this.PositionRelativeY=e[1],t=!0),!t)throw new TypeError("No PositionRelative component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("x"in e&&(this.PositionRelativeX=e.x,t=!0),"y"in e&&(this.PositionRelativeY=e.y,t=!0),!t)throw new TypeError("No PositionRelative component key values were found.")}}}set ShapeTexture(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.ShapeTextureU=e[0],t=!0),"1"in e&&(this.ShapeTextureV=e[1],t=!0),"2"in e&&(this.ShapeTextureWidth=e[2],t=!0),"3"in e&&(this.ShapeTextureHeight=e[3],t=!0),!t)throw new TypeError("No ShapeTexture component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("u"in e&&(this.ShapeTextureU=e.u,t=!0),"v"in e&&(this.ShapeTextureV=e.v,t=!0),"width"in e&&(this.ShapeTextureWidth=e.width,t=!0),"height"in e&&(this.ShapeTextureHeight=e.height,t=!0),!t)throw new TypeError("No ShapeTexture component key values were found.")}}}set BorderColor(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.BorderColorR=e[0],t=!0),"1"in e&&(this.BorderColorG=e[1],t=!0),"2"in e&&(this.BorderColorB=e[2],t=!0),"3"in e&&(this.BorderColorOpacity=e[3],t=!0),!t)throw new TypeError("No BorderColor component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("r"in e&&(this.BorderColorR=e.r,t=!0),"g"in e&&(this.BorderColorG=e.g,t=!0),"b"in e&&(this.BorderColorB=e.b,t=!0),"opacity"in e&&(this.BorderColorOpacity=e.opacity,t=!0),!t)throw new TypeError("No BorderColor component key values were found.")}}}set FillColor(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.FillColorR=e[0],t=!0),"1"in e&&(this.FillColorG=e[1],t=!0),"2"in e&&(this.FillColorB=e[2],t=!0),"3"in e&&(this.FillColorOpacity=e[3],t=!0),!t)throw new TypeError("No FillColor component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("r"in e&&(this.FillColorR=e.r,t=!0),"g"in e&&(this.FillColorG=e.g,t=!0),"b"in e&&(this.FillColorB=e.b,t=!0),"opacity"in e&&(this.FillColorOpacity=e.opacity,t=!0),!t)throw new TypeError("No FillColor component key values were found.")}}}set FillTexture(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.FillTextureU=e[0],t=!0),"1"in e&&(this.FillTextureV=e[1],t=!0),"2"in e&&(this.FillTextureWidth=e[2],t=!0),"3"in e&&(this.FillTextureHeight=e[3],t=!0),!t)throw new TypeError("No FillTexture component index values were found.")}else{if("object"!=typeof e)throw new TypeError("Argument must be an array or object.");{let t=!1;if("u"in e&&(this.FillTextureU=e.u,t=!0),"v"in e&&(this.FillTextureV=e.v,t=!0),"width"in e&&(this.FillTextureWidth=e.width,t=!0),"height"in e&&(this.FillTextureHeight=e.height,t=!0),!t)throw new TypeError("No FillTexture component key values were found.")}}}}var B;function D(e,t){return e===t?NaN:1<<5*e+t-+(t>e)}!function(e){e[e.Created=0]="Created",e[e.Rest=1]="Rest",e[e.HasCallback=2]="HasCallback",e[e.NeedsRebase=3]="NeedsRebase",e[e.NeedsTextureSync=4]="NeedsTextureSync",e[e.Removed=5]="Removed"}(B||(B={}));const F=function(){const{Created:e,Rest:t,HasCallback:i,NeedsRebase:r,NeedsTextureSync:s,Removed:a}=B;let n=0;return n|=D(e,t),n|=D(e,a),n|=D(t,i),n|=D(t,s),n|=D(i,r),n|=D(i,s),n|=D(r,s),n|=D(s,t),n|=D(s,i),n|=D(s,a),n}();class ${constructor(){this.isDefined=!1,this.lowBound=NaN,this.highBound=NaN}clear(){this.isDefined=!1,this.lowBound=NaN,this.highBound=NaN}expandToInclude(e){if(!this.isDefined)return this.lowBound=e,this.highBound=e,void(this.isDefined=!0);e<this.lowBound&&(this.lowBound=e),e>this.highBound&&(this.highBound=e)}truncateToWithin(e,t){if(isNaN(+e)||isNaN(+t))throw new Error("Both values must be numbers");if(t<e)throw new Error("High bound must be greater than or equal to low bound.");this.isDefined&&(e>this.highBound||t<this.lowBound?this.clear():(this.lowBound<e&&(this.lowBound=e),this.highBound>t&&(this.highBound=t)))}overlaps(e){return this.isDefined&&e.isDefined&&this.lowBound<=e.highBound&&this.highBound>=e.lowBound}}class H{constructor(e,t,i){this.stepsBetweenChecks=e,this.renderer=t,this.workScheduler=i,this.sprites=[],this.boundData=[]}onBind(e){return this.bindCallback=e,this}onInit(e){return this.initCallback=e,this}onEnter(e){return this.enterCallback=e,this}onUpdate(e){return this.updateCallback=e,this}onExit(e){return this.exitCallback=e,this}bind(e){let t=0;const i=e.length;let r=this.boundData.length;const s=s=>{for(;r<i;){t++;const i=r++,a=e[i],n=this.renderer.createSprite();this.boundData[i]=a,this.sprites[i]=n;const{initCallback:o,enterCallback:l,bindCallback:h}=this;if((o||h)&&n.enter((e=>{h&&h(e,a),o&&o(e,a),e.TransitionTimeMs=0})),(l||h)&&n.update((e=>{h&&h(e,a),l&&l(e,a)})),t%this.stepsBetweenChecks==0&&s()<=0)break}return r>=i};let a=0;const n=Math.min(i,this.boundData.length),o=i=>{for(;a<n;){t++;const r=a++,s=e[r],n=this.sprites[r];this.boundData[r]=s;const{updateCallback:o,bindCallback:l}=this;if((o||l)&&n.update((e=>{l&&l(e,s),o&&o(e,s)})),t%this.stepsBetweenChecks==0&&i()<=0)break}return a>=n},l=e=>{let r=i;for(;r<this.boundData.length;){t++;const i=this.boundData[r],s=this.sprites[r];if(r++,s.isAbandoned||s.isActive||s.isRemoved){const{exitCallback:e,bindCallback:t}=this;(e||t)&&s.exit((r=>{t&&t(r,i),e&&e(r,i)}))}else s.abandon();if(t%this.stepsBetweenChecks==0&&e()<=0)break}return r>i&&(this.boundData.splice(i,r-i),this.sprites.splice(i,r-i)),this.boundData.length<=i},h={id:this,callback:e=>(t=0,l(e)&&o(e)&&s(e)),runUntilDone:!0};return this.workScheduler.scheduleUniqueTask(h),this}}class j{constructor(){this.internalLifecyclePhase=B.Created}get hasCallback(){return!!(this.enterCallback||this.updateCallback||this.exitCallback)}get lifecyclePhase(){return this.internalLifecyclePhase}set lifecyclePhase(e){!function(e,t){if(!(D(e,t)&F))throw new Error("Illegal sprite lifecycle phase transition.")}(this.internalLifecyclePhase,e),this.internalLifecyclePhase=e}}class U{constructor(e){this.coordinator=e,this[V]=new j}enter(e){if(this.isAbandoned)throw new Error("Cannot add enter callback to abondend sprite.");if(this.isRemoved)throw new Error("Cannot add enter callback to Removed sprite.");const t=this[V];return t.enterCallback=e,t.lifecyclePhase===B.Rest&&(this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=B.HasCallback),this}update(e){if(this.isAbandoned)throw new Error("Cannot add update callback to abandoned sprite.");if(this.isRemoved)throw new Error("Cannot add update callback to Removed sprite.");const t=this[V];return t.updateCallback=e,t.lifecyclePhase===B.Rest&&(this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=B.HasCallback),this}exit(e){if(this.isAbandoned)throw new Error("Cannot add exit callback to abandoned sprite.");if(this.isRemoved)throw new Error("Cannot add exit callback to Removed sprite.");const t=this[V];return t.exitCallback=e,t.toBeRemoved=!0,t.lifecyclePhase===B.Rest&&(this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=B.HasCallback),this}abandon(){if(this.isAbandoned)throw new Error("Cannot abandon a Sprite already marked abandoned.");if(this.isRemoved)throw new Error("Cannot abandon a Sprite that has been removed.");if(this.isActive)throw new Error("Cannot abandon an active Sprite.");const e=this[V];e.isAbandoned=!0,e.enterCallback=void 0,e.updateCallback=void 0,e.exitCallback=void 0,e.toBeRemoved=!0,e.lifecyclePhase=B.Removed}get isActive(){const e=this[V].lifecyclePhase;return e!==B.Created&&e!==B.Removed}get isAbandoned(){return!!this[V].isAbandoned}get isRemoved(){return this[V].lifecyclePhase===B.Removed}}function G(e,t){const i=new $;if(!e.isDefined)return i;const{lowBound:r,highBound:s}=e,a=Math.floor(r/t),n=Math.floor(s/t)+1;return i.expandToInclude(a*t),i.expandToInclude(n*t-1),i}const L="center",q="middle";class O{constructor(e,t,i,r){this.stepsBetweenChecks=e,this.renderer=t,this.workScheduler=i,this.glyphMapper=r,this.selections=[],this.boundData=[],this.textCallback=e=>`${e}`,this.alignCallback=()=>L,this.verticalAlignCallback=()=>q}text(e){return this.textCallback=e,this}align(e){return this.alignCallback=e,this}verticalAlign(e){return this.verticalAlignCallback=e,this}onBind(e){return this.bindCallback=e,this}onInit(e){return this.initCallback=e,this}onEnter(e){return this.enterCallback=e,this}onUpdate(e){return this.updateCallback=e,this}onExit(e){return this.exitCallback=e,this}datumToGlyphs(e){const t=(this.textCallback?this.textCallback.call(e,e):`${e}`).trim(),i=this.alignCallback&&this.alignCallback(e)||L,r=this.verticalAlignCallback&&this.verticalAlignCallback(e)||q,s=[];for(let a=0;a<t.length;a++){let n,o;n="left"===i?.5*(a+1):"right"===i?.5*(a+1-t.length):.5*(a+.75-.5*t.length),o="top"===r?-.5:"bottom"===r?.5:0;const l=this.glyphMapper.getGlyph(t.charAt(a));l&&s.push({datum:e,coords:l,position:{x:n,y:o}})}return s}bind(e){let t=0;const i=e.length;let r=this.boundData.length;const s=s=>{for(;r<i;){t++;const i=r++,a=e[i],n=this.renderer.createSelection();if(this.boundData.push(a),this.selections.push(n),n.onInit(((e,t)=>{this.initCallback&&this.initCallback(e,t.datum)})),n.onEnter(((e,t)=>{this.enterCallback&&this.enterCallback(e,t.datum)})),n.onUpdate(((e,t)=>{this.updateCallback&&this.updateCallback(e,t.datum)})),n.onExit(((e,t)=>{this.exitCallback&&this.exitCallback(e,t.datum)})),n.onBind(((e,t)=>{e.Sides=0,e.ShapeTexture=t.coords,e.PositionRelative=t.position,this.bindCallback&&this.bindCallback(e,t.datum)})),n.bind(this.datumToGlyphs(a)),t%this.stepsBetweenChecks==0&&s()<=0)return!1}return r>=i};let a=0;const n=Math.min(i,this.boundData.length),o=i=>{for(;a<n;){t++;const r=a++,s=e[r],n=this.selections[r];if(this.boundData[r]=s,n.bind(this.datumToGlyphs(s)),t%this.stepsBetweenChecks==0&&i()<=0)return!1}return a>=n},l=e=>{for(;i<this.boundData.length;){t++,this.boundData.pop();if(this.selections.pop().bind([]),t%this.stepsBetweenChecks==0&&e()<=0)return!1}return i>=this.boundData.length},h={id:this,callback:e=>(t=0,l(e)&&o(e)&&s(e)),runUntilDone:!0};return this.workScheduler.scheduleUniqueTask(h),this}}function X(e){return!(!e||!(e instanceof Function||e.callback instanceof Function))}function _(e){if(!X(e))throw new Error("Provided object was not a work task or function.");return e instanceof Function?e:void 0!==e.id?e.id:e.callback}function Z(e){if(!X(e))throw new Error("Provided object was not a work task or function.");return e instanceof Function?{callback:e,id:e}:void 0!==e.id?e:Object.assign(Object.assign({},e),{id:e.callback})}class Y{constructor(){this.idSet=new Set,this.taskList=[]}get length(){return this.taskList.length}hasTaskId(e){return this.idSet.has(e)}hasTask(e){return this.hasTaskId(_(e))}getTaskById(e){if(!this.hasTaskId(e))return;const t=this.findTaskIndexById(e);if(-1===t)throw new Error("Could not find matching task in task list.");return this.taskList[t]}enqueueTask(e){if(this.hasTask(e))return;const t=Z(e);this.idSet.add(t.id),this.taskList.push(t)}dequeueTask(){if(!this.length)throw new Error("No tasks remain to dequeue.");const e=this.taskList.shift();return this.idSet.delete(e.id),e}removeTaskById(e){if(!this.hasTaskId(e))return;const t=this.findTaskIndexById(e);if(-1===t)throw new Error("Could not find matching task in task list.");const[i]=this.taskList.splice(t,1);return this.idSet.delete(i.id),i}removeTask(e){return this.removeTaskById(_(e))}findTaskIndexById(e){let t=-1;for(let i=0;i<this.taskList.length;i++)if(this.taskList[i].id===e){if(-1!==t)throw new Error("Duplicate task found in task list.");t=i}return t}}const Q=Object.freeze({timingFunctions:T,maxWorkTimeMs:20,timeoutMs:0});class J{constructor(e=Q){this.isEnabled=!1,this.isPerformingWork=!1,this.isPerformingAnimationFrameWork=!1,this.isPerformingTimoutWork=!1,this.presentWorkQueue=new Y,this.futureWorkQueue=new Y;const t=Object.assign({},Q,e||{});this.timingFunctions=Object.freeze(Object.assign({},T,t&&t.timingFunctions||{})),this.maxWorkTimeMs=t.maxWorkTimeMs,this.timeoutMs=t.timeoutMs,this.enable()}scheduleTask(e){const t=Z(e);return this.presentWorkQueue.hasTask(t)||this.futureWorkQueue.hasTask(t)||(this.isPerformingWork&&!t.beginImmediately?this.futureWorkQueue.enqueueTask(t):this.presentWorkQueue.enqueueTask(t)),this.updateTimers(),t}getTask(e){const t=_(e),i=this.presentWorkQueue.getTaskById(t),r=this.futureWorkQueue.getTaskById(t);if(i&&r)throw new Error("Found two matching tasks when at most one is allowed.");return i||r||void 0}unscheduleTask(e){const t=_(e),i=this.presentWorkQueue.removeTaskById(t),r=this.futureWorkQueue.removeTaskById(t);if(i&&r)throw new Error("Found two matching tasks when at most one is allowed.");return this.updateTimers(),i||r||void 0}isScheduledTask(e){return this.isScheduledId(_(e))}isScheduledId(e){return this.presentWorkQueue.hasTaskId(e)||this.futureWorkQueue.hasTaskId(e)}scheduleUniqueTask(e){const t=Z(e);return this.unscheduleTask(t),this.scheduleTask(t),t}enable(){return this.isEnabled=!0,this.updateTimers(),this}disable(){return this.isEnabled=!1,this.updateTimers(),this}updateTimers(){const{requestAnimationFrame:e,cancelAnimationFrame:t,setTimeout:i,clearTimeout:r}=this.timingFunctions;if(!this.isEnabled||!this.presentWorkQueue.length&&!this.futureWorkQueue.length)return void 0!==this.animationFrameTimer&&(t(this.animationFrameTimer),this.animationFrameTimer=void 0),void(void 0!==this.timeoutTimer&&(r(this.timeoutTimer),this.timeoutTimer=void 0));if(void 0===this.animationFrameTimer){const t=()=>{this.isEnabled?(this.animationFrameTimer=e(t),this.performAnimationFrameWork()):this.animationFrameTimer=void 0};this.animationFrameTimer=e(t)}if(void 0===this.timeoutTimer){const e=()=>{this.isEnabled?(this.timeoutTimer=i(e,this.timeoutMs),this.performTimeoutWork()):this.timeoutTimer=void 0};this.timeoutTimer=i(e,this.timeoutMs)}}performWork(){if(this.isPerformingWork)throw new Error("Only one invocation of performWork is allowed at a time.");this.isPerformingWork=!0;const{now:e}=this.timingFunctions;let t=0;try{const i=e(),r=()=>this.maxWorkTimeMs+i-e();for(;this.presentWorkQueue.length&&!(t>0&&r()<=0);){let e=this.presentWorkQueue.dequeueTask();if(!this.isPerformingAnimationFrameWork&&(void 0===e.animationOnly||e.animationOnly)){this.futureWorkQueue.enqueueTask(e);continue}t++;const i=e.callback.call(null,r);if(!e.runUntilDone||i)continue;let s=i;for(;!s&&r()>0;)s=e.callback.call(null,r);if(!s){this.futureWorkQueue.enqueueTask(e);break}}}finally{this.isPerformingWork=!1}for(;this.futureWorkQueue.length;){const e=this.futureWorkQueue.dequeueTask();this.scheduleTask(e)}}performAnimationFrameWork(){if(this.isPerformingAnimationFrameWork)throw new Error("Only one invocation of performAnimationFrameWork at a time.");this.isPerformingAnimationFrameWork=!0;try{this.performWork()}finally{this.isPerformingAnimationFrameWork=!1}}performTimeoutWork(){if(this.isPerformingTimoutWork)throw new Error("Only one invocation of performTimoutWork at a time.");this.isPerformingTimoutWork=!0;try{this.performWork()}finally{this.isPerformingTimoutWork=!1}}}const K=500;class ee{constructor(e={}){this.scale=new W(this),this.offset=new W(this),this.sprites=[],this.waitingSprites=[],this.instanceCount=0,this.callbacksIndexRange=new $,this.needsTextureSyncIndexRange=new $,this.needsRebaseIndexRange=new $,this.toBeRemovedIndexRange=new $,this.toBeRemovedTsRange=new $,this.removedIndexRange=new $,this.toDrawTsRange=new $,this.drawTaskId=Symbol("drawTask"),this.textureSyncTaskId=Symbol("textureSyncTask"),this.rebaseCount=0,this.runRemovalTaskId=Symbol("runRemovalTaskId"),this.runAssignWaitingTaskId=Symbol("runAssignWaitingTask"),this.rebaseTaskId=Symbol("rebaseTask"),this.runCallbacksTaskId=Symbol("runCallbacksTask"),this.hitTestTaskId=Symbol("hitTestTask"),this.hitTestParameters={x:0,y:0,width:0,height:0,inclusive:!0};const t=Object.assign({},M,e||{}),i=Object.assign({},M.timingFunctions,t.timingFunctions||{}),{now:s}=i;this.basisTs=s(),this.elapsedTimeMs=()=>s()-this.basisTs,this.workScheduler=new J({timingFunctions:i}),this.container=t.container,this.defaultTransitionTimeMs=t.defaultTransitionTimeMs;const a=new Set(Array.from(this.container.children)),n=window.createREGL||r.default;if(!n)throw new Error("Could not find REGL.");const h=this.regl=n({container:this.container,extensions:["angle_instanced_arrays","EXT_blend_minmax","OES_texture_float","OES_texture_float_linear"]}),u=Array.from(this.container.children).filter((e=>e instanceof HTMLCanvasElement&&!a.has(e)));if(!u.length)throw new Error("Container is missing an inserted canvas.");this.canvas=u[0];const{width:d,height:p}=this.canvas.getBoundingClientRect(),m=Math.min(d,p)||Math.max(d,p)||Math.min(window.innerWidth,window.innerHeight);this.scale.x=m,this.scale.y=m,this.offset.x=d/2,this.offset.y=p/2;const f=this.attributeMapper=new o({maxTextureSize:h.limits.maxTextureSize,desiredSwatchCapacity:t.desiredSpriteCapacity,dataChannelCount:4});this.previousValuesFramebuffer=h.framebuffer({color:h.texture({width:f.textureWidth,height:f.textureHeight,channels:f.dataChannelCount,type:"float32",mag:"nearest",min:"nearest"}),depthStencil:!1}),this.previousValuesTexture=h.texture({width:f.textureWidth,height:f.textureHeight,channels:f.dataChannelCount,type:"float32",mag:"nearest",min:"nearest"}),this.targetValuesArray=new Float32Array(f.totalValues),this.targetValuesTexture=h.texture({width:f.textureWidth,height:f.textureHeight,channels:f.dataChannelCount,data:this.targetValuesArray,type:"float32",mag:"nearest",min:"nearest"}),this.instanceSwatchUvValues=f.generateInstanceSwatchUvValues(),this.instanceIndexValues=new Float32Array(f.totalSwatches);for(let e=0;e<f.totalSwatches;e++)this.instanceIndexValues[e]=e;const g=this.hitTestAttributeMapper=new o({maxTextureSize:h.limits.maxTextureSize,desiredSwatchCapacity:f.totalSwatches,dataChannelCount:4,attributes:[{attributeName:"Hit"}]});this.instanceHitTestUvValues=this.hitTestAttributeMapper.generateInstanceSwatchUvValues(),this.hitTestValuesFramebuffer=h.framebuffer({color:h.texture({width:g.textureWidth,height:g.textureHeight,channels:g.dataChannelCount,type:"uint8",mag:"nearest",min:"nearest"}),depthStencil:!1}),this.hitTestValues=new Uint8Array(g.dataChannelCount*g.totalSwatches),this.glyphMapper=new N(t.glyphMapper);for(const e of t.glyphs.split(""))this.glyphMapper.addGlyph(e);var T;this.sdfTexture=h.texture({height:this.glyphMapper.textureSize,width:this.glyphMapper.textureSize,min:"linear",mag:"linear",wrap:"clamp",data:this.glyphMapper.textureData,format:"luminance",type:"float32"}),this.instanceSwatchUvBuffer=this.regl.buffer(this.instanceSwatchUvValues),this.instanceIndexBuffer=this.regl.buffer(this.instanceIndexValues),this.instanceHitTestUvBuffer=this.regl.buffer(this.instanceHitTestUvValues),this.instanceRebaseUvValues=new Float32Array(this.instanceSwatchUvValues.length),this.instanceRebaseUvBuffer=this.regl.buffer({usage:"dynamic",type:"float",data:this.instanceRebaseUvValues}),this.drawCommand=(0,(T=this).regl)({blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:1},equation:{rgb:"add",alpha:"max"}},frag:l`
precision lowp float;

/**
 * View matrix for converting from world space to clip space.
 */
uniform mat3 viewMatrix;

/**
 * Signed-distance field (SDF) texture. Sampled for implementing glyphs of text.
 */
uniform sampler2D sdfTexture;

/**
 * Varying time value, eased using cubic-in-out between the previous and target
 * timestamps for this Sprite.
 */
varying float varyingT;

/**
 * Interpolated, per-vertex coordinate attributes for the quad into which the
 * sprite will be rendered.
 */
varying vec4 varyingVertexCoordinates;

/**
 * Threshold distance values to consider the pixel outside the shape (X) or
 * inside the shape (Y). Values between constitue the borde.
 */
varying vec2 varyingBorderThresholds;

/**
 * Aspect ratio of the sprite's renderable area (XY) and their inverses (ZW).
 * One component of each pair will be 1. For the XY pair, the other component
 * be be greater than 1. and for the inverse pair it will be smaller.
 *
 * For example, a rectangle that's twice as wide as it is tall wolud have
 * varyingAspectRatio equal to vec4(2., 1., .5, 1.).
 */
varying vec4 varyingAspectRatio;

/**
 * Color attributes.
 */
varying vec4 varyingBorderColor;
varying vec4 varyingFillColor;

/**
 * Shape attributes used by fragment shader.
 */
varying float varyingPreviousSides;
varying float varyingTargetSides;
varying vec4 varyingPreviousShapeTexture;
varying vec4 varyingTargetShapeTexture;

// Import utility shader functions).
${c()}

const float PI = 3.1415926535897932384626433832795;

/**
 * Given a line segment described by two points (a,b), find the point along that
 * line segment nearest to a point of interest (p).
 */
vec2 closestPoint(vec2 a, vec2 b, vec2 p) {
  vec2 pa = p - a;
  vec2 ba = b - a;
  vec2 baNorm = normalize(ba);
  float baLen = length(ba);
  float projectedLen = dot(baNorm, pa);
  vec2 closest =
    projectedLen < 0. ? a :
    projectedLen > baLen ? b :
    a + baNorm * projectedLen;
  return closest;
}

/**
 * Matrix to flip XY coordinates for theta computation. To orient polygons and
 * stars pointing upwards, we compute angles counter-clockwise from vertical.
 */
const mat2 FLIP_MATRIX = mat2(vec2(0., 1.), vec2(-1., 0.));

/**
 * Given a point in the range (-1,-1) to (1,1), compute the angle to that point,
 * going counter-clockwise from vertical.
 */
float computeTheta(vec2 point) {
  vec2 f = FLIP_MATRIX * point;
  return atan(f.y, f.x) + PI;
}

/**
 * Given the varying coordinates of interest, the dimensions of the shape's
 * bounding box, the number of sides, and a list of repeating offset radii,
 * determine the signed distance from the coordinates to the nearest edge of the
 * shape.
 *
 * @param sides Number of sides of the polygon or star.
 * @param radii List of four repeating offset radii to render stars. If all
 * values are 0., then the rendered distance will be a regular polygon.
 */
float getDistStar(int sides, vec4 radii) {
  float fSides = float(sides);

  // Flip radii (0. means align with unit circle, 1. means center of shape).
  radii = 1. - radii;

  // Angle to cut through the midpoint of a regular polygon's side.
  float piSides = PI / fSides;

  // With the polygon pointed up, this is the angle (counter-clockwise from top)
  // to the point just before crossing the X-axis. For a triangle, this will
  // just be the same as piSides.
  float wideAngle = floor(fSides * .5) * piSides;

  // Compute radius for dilation to fill bounding box.
  float dilation = 1. / max(sin(wideAngle), sin(piSides));

  // Compute the height of the shape, for centering.
  float height = dilation * (1. + max(cos(PI - 2. * wideAngle), cos(piSides)));

  // The point of interest starts with the varyingVertexCoordinates, but shifted
  // to center the shape vertically.
  vec2 poi = 2. * varyingVertexCoordinates.xy + vec2(0., 2. - height);

  // Compute theta for point of interest, counter-clockwise from vertical.
  float theta = computeTheta(poi);

  // Incorporate aspect ratio calculation. This ensures that distances to
  // borders do not stretch with the shape.
  vec2 aspect = varyingAspectRatio.xy;
  poi *= aspect;

  // Compute which side of the star we're on, and use this to compute adjustment
  // to a and b points. This creates the star effect.
  float side = floor(theta / PI * .5 * fSides);

  float minDistance = 1.e20;
  float distanceSign;

  // Look at sides to the left/right (clockwise) to find the closest.
  for (int i = -1; i < 2; i++) {
    float thisSide = side + float(i);
    float m = mod(thisSide + 4., 4.);

    vec2 adjust =
      m < 1. ? radii.xy :
      m < 2. ? radii.yz :
      m < 3. ? radii.zw :
      radii.wx;

    // Find the ab line segment endpoints.
    float thetaA = 2. * thisSide * piSides;
    float thetaB = thetaA + 2. * piSides;
    vec2 a = aspect * dilation * adjust.x * vec2(-sin(thetaA), cos(thetaA));
    vec2 b = aspect * dilation * adjust.y * vec2(-sin(thetaB), cos(thetaB));

    // Find the closest point on the segment and update minDistance.
    vec2 c = closestPoint(a, b, poi).xy;
    minDistance = min(minDistance, distance(poi, c));

    // If we're in our own segment, capture the distance sign.
    if (i == 0) {
      // Use cross product to determine if we're inside or outside the line.
      distanceSign = sign(cross(vec3(b - a, 0.), vec3(poi - c, 0.)).z);
    }
  }

  return minDistance * distanceSign;
}

/**
 * Convenience method for calling getDistStar() with a fixed size array of 0.
 * values to create a regular polygon.
 */
float getDistPolygon(int sides) {
  return getDistStar(sides, vec4(0.));
}

/**
 * Estimate the distance from the varying vertex coordinate to the nearest point
 * on an ellipse of the specified aspect ratio. Mathematically, a closed-form
 * solution for this problem has not yet been discovered.
 *
 * Higher accuracy estimates of ellipse distance are possible with more
 * computation steps, but the procedure used here yields sufficient accurancy
 * for data visualization purposes.
 */
float getDistEllipse() {
  // All quadrants can be treated the same, so use the absolute value of the
  // vertex coordinates, and flip if needed so that the X dimension is always
  // the greater.
  bool flipped = varyingAspectRatio.x < varyingAspectRatio.y;
  vec4 aspectRatio = flipped ? varyingAspectRatio.yxwz : varyingAspectRatio;

  // Point of interest in the expanded circle (before aspect ratio stretching).
  vec2 circlePoint = 2. * abs(
      flipped ? varyingVertexCoordinates.yx : varyingVertexCoordinates.xy);

  // Capture length for inside/outside checking.
  float len = length(circlePoint);

  // Point of interest in the ellipse (after aspect ratio stretching).
  vec2 ellipsePoint = circlePoint * aspectRatio.xy;

  // Compute the angle from the x-axis up to the point of interest.
  float theta = PI - atan(circlePoint.y, -circlePoint.x);

  // Find the point where a ray from the origin through c hits the ellipse.
  vec2 p1 = aspectRatio.xy * vec2(cos(theta), sin(theta));

  // Find a second point by casting up from the x-axis. If the point of interest
  // is outside the ellipse and past the tip, use the tip coordinate.
  float invAr2 = aspectRatio.z * aspectRatio.z;
  vec2 p2 = ellipsePoint.x > aspectRatio.x ? vec2(aspectRatio.x, 0.) :
    vec2(ellipsePoint.x, sqrt(1. - ellipsePoint.x * ellipsePoint.x * invAr2));

  // Take the minimum distance between ray intersection point and vertical.
  float dist = min(distance(ellipsePoint, p1), distance(ellipsePoint, p2));

  // If the point of interest is outside of the ellipse, smooth by checking the
  // distance to one more point: the point on the ellipse between p1 and p2 such
  // that its X coordinate is half way between.
  if (len > 1.) {
    vec2 pm = mix(p1, p2, .5);
    pm.y = sqrt(1. - pm.x * pm.x * invAr2);
    dist = min(dist, distance(ellipsePoint, pm));
  }

  // Return signed distance.
  return dist * sign(1. - len);
}

/**
 * Compute the signed distance from the point of interest to the nearest edge of
 * the sprite bonding box.
 */
float getDistRect() {
  // All quadrants can be treated the same, so we limit our computation to the
  // top right.
  vec2 ar = varyingAspectRatio.xy;
  vec2 p = ar * 2. * abs(varyingVertexCoordinates.xy);

  // If the point of intrest is beyond the top corner, return the negative
  // distance to that corner.
  if (all(greaterThan(p, ar))) {
    return -distance(p, ar);
  }

  // Determine distance to nearest edge.
  vec2 d = ar - p;
  vec2 dabs = abs(d);
  return dabs.x < dabs.y ? d.x : d.y;
}

/**
 * Sample the distance from the sdfTexture. The texture is assumed to have
 * one-dimensional distances in the X and Y componets and two-dimensional
 * distance in the Z component.
 *
 * @param shapeTexture UV coordinates and width/height of the region of the SDF
 * texture within which to sample (corresponds to the glyph being rendered).
 */
float getDistSDF(vec4 shapeTexture) {
  vec2 textureUv =
      shapeTexture.xy +
      shapeTexture.zw * varyingVertexCoordinates.zw;
  return 2. * texture2D(sdfTexture, textureUv).z - 1.;
}

/**
 * Generic distance function that calls through to one of the more specific
 * distance functions.
 *
 * @param sides Number of sides of the polygon/star, or special value:
 *  s < 0      : Reserved / Undefined.
 *  s == 0     : Use SDF texture coordinates.
 *  s == 1     : Circle.
 *  s == 2     : Filled rectangle.
 *  s > 2      : Polygon / Star.
 * @param textureUv Offset into SDF texture.
 */
float getDist(int sides, vec4 shapeTexture) {
  return
    sides == 0 ? getDistSDF(shapeTexture) :
    sides == 1 ? getDistEllipse() :
    sides == 2 ? getDistRect() :
    sides > 2 ? getDistPolygon(sides) :
    1.; // Reserved / undefined.
}

void main () {
  int previousSides = int(varyingPreviousSides);
  int targetSides = int(varyingTargetSides);

  float previousDistance = getDist(previousSides, varyingPreviousShapeTexture);
  float targetDistance = getDist(targetSides, varyingTargetShapeTexture);
  float signedDistance = mix(previousDistance, targetDistance, varyingT);

  gl_FragColor =
    signedDistance < varyingBorderThresholds.x ? vec4(0.) :
    signedDistance < varyingBorderThresholds.y ? varyingBorderColor :
    varyingFillColor;
}
`,vert:x(T.attributeMapper),attributes:{vertexCoordinates:[[-.5,-.5,0,1],[.5,-.5,1,1],[-.5,.5,0,0],[.5,.5,1,0]],instanceSwatchUv:{buffer:T.instanceSwatchUvBuffer,divisor:1},instanceIndex:{buffer:T.instanceIndexBuffer,divisor:1}},uniforms:{ts:()=>T.elapsedTimeMs(),instanceZ:()=>1/(1+T.instanceCount),viewMatrix:()=>T.getViewMatrix(),viewMatrixScale:()=>T.getViewMatrixScale(),projectionMatrix:e=>T.getProjectionMatrix(e),sdfTexture:T.sdfTexture,previousValuesTexture:T.previousValuesFramebuffer,targetValuesTexture:T.targetValuesTexture},primitive:"triangle strip",count:4,instances:()=>T.instanceCount}),this.rebaseCommand=function(e){const{regl:t,attributeMapper:i}=e;return t({frag:w(i),vert:b(i),attributes:{vertexCoordinates:[[-.5,-.5],[.5,-.5],[-.5,.5],[.5,.5]],instanceRebaseUv:{buffer:()=>e.instanceRebaseUvBuffer,divisor:1}},uniforms:{ts:()=>e.elapsedTimeMs(),targetValuesTexture:e.targetValuesTexture,previousValuesTexture:e.previousValuesTexture},primitive:"triangle strip",count:4,instances:()=>e.rebaseCount,framebuffer:()=>e.previousValuesFramebuffer})}(this),this.hitTestCommand=function(e){const{regl:t,attributeMapper:i,hitTestAttributeMapper:r}=e;return t({frag:l`
precision lowp float;

varying float varyingHitTestResult;

void main () {
  gl_FragColor = vec4(vec3(varyingHitTestResult), 1.);
}
`,vert:v(r,i),attributes:{vertexCoordinates:[[-.5,-.5],[.5,-.5],[-.5,.5],[.5,.5]],instanceSwatchUv:{buffer:e.instanceSwatchUvBuffer,divisor:1},instanceHitTestUv:{buffer:e.instanceHitTestUvBuffer,divisor:1}},uniforms:{ts:()=>e.elapsedTimeMs(),hitTestCoordinates:()=>[e.hitTestParameters.x,e.hitTestParameters.y,e.hitTestParameters.width,e.hitTestParameters.height],inclusive:()=>e.hitTestParameters.inclusive?1:0,viewMatrix:()=>e.getViewMatrix(),viewMatrixScale:()=>e.getViewMatrixScale(),targetValuesTexture:e.targetValuesTexture,previousValuesTexture:e.previousValuesTexture},primitive:"triangle strip",count:4,instances:()=>e.instanceCount,framebuffer:()=>e.hitTestValuesFramebuffer})}(this),this.queueDraw()}hitTest(e,t,i=0,r=0,s=!0){if(this.hitTestParameters.x=e,this.hitTestParameters.y=t,this.hitTestParameters.width=i,this.hitTestParameters.height=r,this.hitTestParameters.inclusive=s,this.hitTestPromise)return this.hitTestPromise;let a;this.hitTestPromise=new Promise(((e,t)=>{a={resolve:e,reject:t}}));const n={id:this.hitTestTaskId,callback:()=>{try{const e=this.performHitTest();a.resolve(e)}catch(e){a.reject(e)}finally{delete this.hitTestPromise}}};return this.hitTestPromise.cancel=()=>{this.workScheduler.unscheduleTask(n),delete this.hitTestPromise,a.reject(new Error("HitTest Cancelled."))},this.workScheduler.scheduleUniqueTask(n),this.hitTestPromise}performHitTest(){this.hitTestCommand(),this.regl.read({x:0,y:0,width:this.hitTestAttributeMapper.textureWidth,height:this.hitTestAttributeMapper.textureHeight,data:this.hitTestValues,framebuffer:this.hitTestValuesFramebuffer});const e=[];for(let t=0;t<this.instanceCount;t++)if(this.hitTestValues[4*t]>0){this.sprites[t][V].lifecyclePhase!==B.Removed&&e.push(this.sprites[t])}return{parameters:this.hitTestParameters,hits:e}}doDraw(){const e=this.elapsedTimeMs();try{this.drawCommand()}finally{this.toDrawTsRange.truncateToWithin(e,1/0),this.toDrawTsRange.isDefined&&this.queueDraw(!1)}}queueDraw(e=!0){this.queueTask(this.drawTaskId,(()=>this.doDraw()),e)}snapshot(){return s(this,void 0,void 0,(function*(){return this.drawCommand(),new Promise(((e,t)=>{this.canvas.toBlob((i=>i?e(i):t(i)))}))}))}getViewMatrix(){return[4*this.scale.x,0,0,0,-4*this.scale.y,0,4*this.offset.x,4*this.offset.y,1]}getViewMatrixScale(){return[4*this.scale.x,4*this.scale.y,.25/this.scale.x,.25/this.scale.y]}getProjectionMatrix({viewportWidth:e,viewportHeight:t}){return[1/e,0,0,0,-1/t,0,-1,1,1]}getNextIndex(){if(!this.removedIndexRange.isDefined)return this.sprites.length<this.attributeMapper.totalSwatches?this.sprites.length:void 0;const{lowBound:e,highBound:t}=this.removedIndexRange;for(let i=e;i<=t;i++){if(this.sprites[i][V].lifecyclePhase===B.Removed)return i===t?this.removedIndexRange.clear():this.removedIndexRange.truncateToWithin(i+1,t),i}throw new Error("No removed sprites found in removed index range.")}createSprite(){const e=Object.seal(new U(this));return this.waitingSprites.length>0||!this.removedIndexRange.isDefined&&this.sprites.length>=this.attributeMapper.totalSwatches?this.waitingSprites.push(e):this.assignSpriteToIndex(e,this.getNextIndex()),e}assignSpriteToIndex(e,t){const i=e[V];if(i.lifecyclePhase!==B.Created)throw new Error("Only sprites in the Created phase can be assigned indices");const{valuesPerSwatch:r}=this.attributeMapper,s=this.targetValuesArray.subarray(t*r,(t+1)*r);s.fill(0),i.lifecyclePhase=B.Rest,i.index=t,i.spriteView=Object.seal(new E(s)),this.sprites[t]=e,this.instanceCount<=t+1&&(this.instanceCount=t+1)}markSpriteCallback(e){this.callbacksIndexRange.expandToInclude(e),this.queueRunCallbacks()}removeSprite(e){if(e.isRemoved)throw new Error("Sprite can be removed only once.");const t=e[V];t.index===this.instanceCount-1&&this.instanceCount--,t.lifecyclePhase=B.Removed,t.spriteView[I]=void 0,this.removedIndexRange.expandToInclude(t.index)}queueTask(e,t,i=!1){this.workScheduler.isScheduledId(e)||this.workScheduler.scheduleTask({id:e,callback:t.bind(this),beginImmediately:i})}queueRebase(){this.queueTask(this.rebaseTaskId,(()=>function(e){if(!e.needsRebaseIndexRange.isDefined)throw new Error("No sprites are queued for rebase.");e.rebaseCount=0;const{lowBound:t,highBound:i}=e.needsRebaseIndexRange;for(let r=t;r<=i;r++){const t=e.sprites[r][V];t.lifecyclePhase===B.NeedsRebase&&(e.needsTextureSyncIndexRange.expandToInclude(r),t.lifecyclePhase=B.NeedsTextureSync,e.instanceRebaseUvValues[2*e.rebaseCount]=e.instanceSwatchUvValues[2*r],e.instanceRebaseUvValues[2*e.rebaseCount+1]=e.instanceSwatchUvValues[2*r+1],e.rebaseCount++)}if(!e.rebaseCount)throw new Error("No sprites were found to need rebase.");e.queueTextureSync(),e.instanceRebaseUvBuffer(e.instanceRebaseUvValues.subarray(0,2*e.rebaseCount)),e.rebaseCommand(),e.previousValuesFramebuffer.use((()=>e.previousValuesTexture({copy:!0}))),e.needsRebaseIndexRange.clear()}(this)))}queueAssignWaiting(){this.queueTask(this.runAssignWaitingTaskId,this.runAssignWaiting)}runAssignWaiting(e){return function(e,t,i){const{removedIndexRange:r,sprites:s,waitingSprites:a}=e;if(!r.isDefined)throw new Error("No removed indices available to assign.");if(!a.length)throw new Error("No waiting sprites to assign.");let n=0,o=r.lowBound,l=1,h=!1;for(;n<a.length&&o<=r.highBound&&!(n>0&&l++%i==0&&t()<=0);){for(;n<a.length&&a[n][V].isAbandoned;)n++;if(n>=a.length)break;for(;o<=r.highBound&&!s[o].isRemoved;)o++;if(o>r.highBound)throw new Error("Removed index range ended on a non-removed sprite.");const t=a[n],i=s[o];e.assignSpriteToIndex(t,i[V].index);const l=t[V];l.hasCallback&&(h=!0,l.lifecyclePhase=B.HasCallback,e.callbacksIndexRange.expandToInclude(l.index)),n++,o++}a.splice(0,n),o>r.highBound?r.clear():r.truncateToWithin(o,r.highBound),h&&e.queueRunCallbacks(),a.length&&r.isDefined&&e.queueAssignWaiting()}(this,e,K)}queueRunCallbacks(){this.queueTask(this.runCallbacksTaskId,this.runCallbacks)}runCallbacks(e){return function(e,t,i){if(!e.callbacksIndexRange.isDefined)throw new Error("Running callbacks requires a range of indices.");const{lowBound:r,highBound:s}=e.callbacksIndexRange;let a,n;e.callbacksIndexRange.clear();let o=!1,l=!1;const h=e.elapsedTimeMs(),c=()=>{if(!n)throw new Error("Attempted to re-run afterCallback steps.");const t=n.spriteView;t.TransitionTimeMs+=h,e.toDrawTsRange.expandToInclude(t.TransitionTimeMs),t.TransitionTimeMs>h?(o=!0,n.lifecyclePhase=B.NeedsRebase,e.needsRebaseIndexRange.expandToInclude(n.index)):(l=!0,n.lifecyclePhase=B.NeedsTextureSync,e.needsTextureSyncIndexRange.expandToInclude(n.index),n.toBeRemoved&&!n.hasCallback&&t[I].fill(0)),a=void 0,n=void 0};let u=r;try{let h=1;for(;u<=s&&!(u>r&&h++%i==0&&t()<=0);){if(a=e.sprites[u],n=a[V],u++,n.lifecyclePhase!==B.HasCallback)continue;let t;if(n.enterCallback)t=n.enterCallback,n.enterCallback=void 0;else if(n.updateCallback)t=n.updateCallback,n.updateCallback=void 0;else{if(!n.exitCallback)throw new Error("Sprite in HasCallback state missing callbacks.");t=n.exitCallback,n.exitCallback=void 0}n.spriteView.TransitionTimeMs=e.defaultTransitionTimeMs,h=0,t.call(a,n.spriteView),c()}}catch(e){throw n&&n.lifecyclePhase===B.HasCallback&&c(),e}finally{o&&e.queueRebase(),l&&e.queueTextureSync(),u<=s&&(e.callbacksIndexRange.expandToInclude(u),e.callbacksIndexRange.expandToInclude(s)),e.callbacksIndexRange.isDefined&&e.queueRunCallbacks(),e.toDrawTsRange.isDefined&&e.queueDraw()}return!0}(this,e,K)}queueRemovalTask(){this.queueTask(this.runRemovalTaskId,this.runRemoval)}runRemoval(e){return function(e,t,i){if(!e.toBeRemovedIndexRange.isDefined||!e.toBeRemovedTsRange.isDefined)throw new Error("No sprites are queued for removal.");const r=e.elapsedTimeMs();if(r<e.toBeRemovedTsRange.lowBound)return e.queueRemovalTask(),!0;let{lowBound:s,highBound:a}=e.toBeRemovedIndexRange;e.toBeRemovedIndexRange.clear(),e.toBeRemovedTsRange.clear();let n=s;try{let o=1;for(;n<=a&&!(n>s&&o++%i==0&&t()<=0);n++){const t=e.sprites[n][V];t.toBeRemoved&&t.lifecyclePhase===B.Rest&&(t.spriteView.TransitionTimeMs>r?(e.toBeRemovedIndexRange.expandToInclude(n),e.toBeRemovedTsRange.expandToInclude(t.spriteView.TransitionTimeMs)):(t.spriteView[I].fill(0),t.lifecyclePhase=B.NeedsTextureSync,e.needsTextureSyncIndexRange.expandToInclude(t.index)))}}finally{if(e.needsTextureSyncIndexRange.isDefined&&e.queueTextureSync(),n<a){e.toBeRemovedIndexRange.expandToInclude(n+1),e.toBeRemovedIndexRange.expandToInclude(a);for(let t=n+1;t<=a;t++){const i=e.sprites[t][V];!0===i.toBeRemoved&&i.lifecyclePhase===B.Rest&&e.toBeRemovedTsRange.expandToInclude(i.spriteView.TransitionTimeMs)}}e.toBeRemovedIndexRange.isDefined&&e.queueRemovalTask()}return!0}(this,e,K)}queueTextureSync(){this.queueTask(this.textureSyncTaskId,(()=>function(e){if(!e.needsTextureSyncIndexRange.isDefined)throw new Error("No sprites are in need of texture sync.");const{swatchesPerRow:t,textureWidth:i,valuesPerRow:r}=e.attributeMapper;if(e.needsRebaseIndexRange.isDefined){const i=G(e.needsRebaseIndexRange,t);if(G(e.needsTextureSyncIndexRange,t).overlaps(i))return e.queueRebase(),e.queueTextureSync(),!0}const{lowBound:s,highBound:a}=e.needsTextureSyncIndexRange,n=Math.floor(s/t),o=Math.floor(a/t)+1,l=o-n,h=e.targetValuesArray.subarray(n*r,o*r);let c=!1,u=!1;const d=e.elapsedTimeMs(),p=n*t,m=Math.min(o*t-1,e.sprites.length-1);for(let t=p;t<=m;t++){const i=e.sprites[t],r=i[V];if(r.lifecyclePhase===B.NeedsRebase)throw new Error("Sprite is in the wrong lifecycle phase for sync.");r.lifecyclePhase===B.NeedsTextureSync&&(r.hasCallback?(c=!0,r.lifecyclePhase=B.HasCallback,e.callbacksIndexRange.expandToInclude(t)):r.toBeRemoved?r.spriteView.TransitionTimeMs<=d?e.removeSprite(i):(u=!0,r.lifecyclePhase=B.Rest,e.toBeRemovedIndexRange.expandToInclude(t),e.toBeRemovedTsRange.expandToInclude(r.spriteView.TransitionTimeMs)):r.lifecyclePhase=B.Rest)}e.waitingSprites.length&&e.removedIndexRange.isDefined&&e.queueAssignWaiting(),c&&e.queueRunCallbacks(),u&&e.queueRemovalTask(),e.needsTextureSyncIndexRange.clear();const f={data:h,width:i,height:l};return e.targetValuesTexture.subimage(f,0,n),!0}(this)))}createSelection(){return new H(K,this,this.workScheduler)}createTextSelection(){return new O(K,this,this.workScheduler,this.glyphMapper)}}e.Scene=class{constructor(e={}){this[A]=new ee(e)}get scale(){return this[A].scale}get offset(){return this[A].offset}get canvas(){return this[A].canvas}elapsedTimeMs(){return this[A].elapsedTimeMs()}createSprite(){return this[A].createSprite()}hitTest(e,t,i=0,r=0,s=!0){return this[A].hitTest(e,t,i,r,s)}createSelection(){return this[A].createSelection()}createTextSelection(){return this[A].createTextSelection()}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=megaplot-v0.1.2.es2015.min.js.map
