/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright © 2016-2017 Mapbox, Inc.
 * This code available under the terms of the BSD 2-Clause license.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("regl")):"function"==typeof define&&define.amd?define(["exports","regl"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).megaplot=e.megaplot||{},e.REGL)}(this,(function(e,t){"use strict";function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=i(t);function a(e,t,i,r){return new(i||(i=Promise))((function(a,s){function n(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(n,o)}l((r=r.apply(e,t||[])).next())}))}const s=Object.freeze(["r","g","b","a"]),n=Object.freeze({dataChannelCount:4,desiredSwatchCapacity:1/0,attributes:[{attributeName:"TransitionTimeMs",isTimestamp:!0},{attributeName:"PositionWorld",isInterpolable:!0,components:["X","Y"]},{attributeName:"SizeWorld",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"OrderZ",isInterpolable:!0,minValue:0,maxValue:1},{attributeName:"GeometricZoom",isInterpolable:!0,isBroadcastable:!0,components:["X","Y"]},{attributeName:"PositionPixel",isInterpolable:!0,components:["X","Y"]},{attributeName:"SizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"MaxSizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"MinSizePixel",isInterpolable:!0,isBroadcastable:!0,components:["Width","Height"]},{attributeName:"PositionRelative",isInterpolable:!0,components:["X","Y"]},{attributeName:"Sides"},{attributeName:"ShapeTexture",components:["U","V","Width","Height"]},{attributeName:"BorderRadiusPixel",isInterpolable:!0},{attributeName:"BorderRadiusRelative",isInterpolable:!0},{attributeName:"BorderPlacement",isInterpolable:!0},{attributeName:"BorderColor",isInterpolable:!0,components:["R","G","B","Opacity"]},{attributeName:"FillColor",isInterpolable:!0,components:["R","G","B","Opacity"]}]});class o{constructor(e){const t=Object.assign({},n,e||{});if(!isFinite(t.maxTextureSize)&&!isFinite(t.desiredSwatchCapacity))throw new RangeError("Cannot map attributes to texture of infinite size");this.dataChannelCount=t.dataChannelCount,this.maxTextureSize=t.maxTextureSize,this.desiredSwatchCapacity=t.desiredSwatchCapacity,this.attributes=t.attributes,this.attributeComponentIndices={},this.attributeComponentNames=[],this.componentToAttributeMap={},this.isAttributeTimestamp=[];for(const e of this.attributes){const{attributeName:t,components:i}=e;for(const r of i||[""]){const i=`${t}${r}`;if(i in this.attributeComponentIndices)throw new Error(`Duplicate attribute component name detected: ${i}`);const a=this.attributeComponentNames.length;this.attributeComponentNames[a]=i,this.attributeComponentIndices[i]=a,this.componentToAttributeMap[i]=e,this.isAttributeTimestamp[a]=!!e.isTimestamp}}for(const e of this.attributes){if(!e.isInterpolable)continue;const{attributeName:t,components:i}=e;for(const r of i||[""]){const i=`${t}${r}Delta`;if(i in this.attributeComponentIndices)throw new Error(`Duplicate attribute component name detected: ${i}`);const a=this.attributeComponentNames.length;this.attributeComponentNames[a]=i,this.attributeComponentIndices[i]=a,this.isAttributeTimestamp[a]=!!e.isTimestamp}}Object.freeze(this.attributeComponentIndices),Object.freeze(this.attributeComponentNames),Object.freeze(this.isAttributeTimestamp),this.texelsPerSwatch=Math.ceil(this.attributeComponentNames.length/this.dataChannelCount),this.valuesPerSwatch=this.texelsPerSwatch*this.dataChannelCount,this.bytesPerSwatch=4*this.valuesPerSwatch,this.swatchesPerRow=Math.floor(this.maxTextureSize/this.texelsPerSwatch),this.textureWidth=this.texelsPerSwatch*this.swatchesPerRow,this.textureHeight=this.maxTextureSize,this.totalSwatches=this.swatchesPerRow*this.textureHeight,this.totalSwatches>this.desiredSwatchCapacity&&(this.swatchesPerRow=Math.min(this.swatchesPerRow,Math.ceil(Math.sqrt(this.desiredSwatchCapacity/this.texelsPerSwatch))),this.textureWidth=this.texelsPerSwatch*this.swatchesPerRow,this.textureHeight=Math.min(this.textureHeight,Math.ceil(this.desiredSwatchCapacity/this.swatchesPerRow)),this.totalSwatches=this.swatchesPerRow*this.textureHeight),this.valuesPerRow=this.swatchesPerRow*this.valuesPerSwatch,this.bytesPerRow=4*this.valuesPerRow,this.totalTexels=this.textureWidth*this.textureHeight,this.totalValues=this.totalTexels*this.dataChannelCount,this.totalBytes=4*this.totalValues,Object.freeze(this)}generateTexelReaderGLSL(e="texelValues",t="dataTexture",i="instanceSwatchUv"){const r=[],a=this.texelsPerSwatch;for(let s=0;s<a;s++){const a=(s%this.texelsPerSwatch+.5)/this.texelsPerSwatch/this.swatchesPerRow,n=(Math.floor(s/this.texelsPerSwatch)+.5)/this.textureHeight;r.push(`${e}[${s}] = texture2D(${t}, ${i} + vec2(${a}, ${n}));`)}return r.join("\n")}generateAttributeDefinesGLSL(e,t="texelValues"){return[...this.attributes.map((i=>{const{attributeName:r}=i,a=(i.components||[""]).map((e=>{const i=this.attributeComponentIndices[`${r}${e}`],a=Math.floor(i/this.dataChannelCount),n=s[i%this.dataChannelCount];return`${t}[${a}].${n}`})).join(", "),n=i.components?`vec${i.components.length}(${a})`:a;return`#define ${e}${r}() ${n}`})),...this.attributes.filter((e=>e.isInterpolable)).map((i=>{const{attributeName:r}=i,a=(i.components||[""]).map((e=>{const i=this.attributeComponentIndices[`${r}${e}Delta`],a=Math.floor(i/this.dataChannelCount),s=["r","g","b","a"][i%this.dataChannelCount];return`${t}[${a}].${s}`})).join(", "),s=i.components?`vec${i.components.length}(${a})`:a;return`#define ${e}${r}Delta() ${s}`}))].join("\n")}generateRebaseFragmentGLSL(e="previousTexelValues",t="targetTexelValues",i="texelIndex",r="rebaseTs"){const a={};for(const i of this.attributes){const{attributeName:n}=i;for(const o of i.components||[""]){const l=`${n}${o}`,h=this.attributeComponentIndices[l],c=Math.floor(h/this.dataChannelCount),d=s[h%this.dataChannelCount],u=`${e}[${c}].${d}`,p=`${t}[${c}].${d}`;if(c in a||(a[c]={}),i.isTimestamp){const e=`${r};`;a[c][d]=e}else if(i.isInterpolable){const t=`${l}Delta`,i=this.attributeComponentIndices[t],n=Math.floor(i/this.dataChannelCount),o=s[i%this.dataChannelCount];n in a||(a[n]={});const h=`${e}[${n}].${o}`;a[c][d]=`computeValueAtTime(${u}, ${h}, ${p}, ${r});`,a[n][o]=`computeDeltaAtTime(${u}, ${h}, ${p}, ${r});`}else a[c][d]=`computeThresholdValue(${u}, ${p}, ${r});`}}const n=[];for(let e=0;e<this.texelsPerSwatch;e++){const t=a[e];n.push(`if (${i} < ${e}.5) {`);for(let e=0;e<this.dataChannelCount;e++){const i=s[e];i in t&&n.push(`  gl_FragColor.${i} = ${t[i]}`)}n.push("  return;"),n.push("}")}return n.join("\n")}generateInstanceSwatchUvValues(){const e=new Float32Array(2*this.totalSwatches);for(let t=0;t<this.textureHeight;t++)for(let i=0;i<this.swatchesPerRow;i++){const r=2*(t*this.swatchesPerRow+i);e[r]=i/this.swatchesPerRow,e[r+1]=t/this.textureHeight}return e}}class l{constructor(e){this.callbackFn=e,this.xValue=0,this.yValue=0}get x(){return this.xValue}set x(e){if(isNaN(+e))throw new RangeError("x cannot be NaN");this.xValue=e,this.callbackFn()}get y(){return this.yValue}set y(e){if(isNaN(+e))throw new RangeError("y cannot be NaN");this.yValue=e,this.callbackFn()}}function h(e,...t){const i=[];for(let r=0;r<t.length;r++)i.push(e[r],`${t[r]}`);return i.push(e[e.length-1]),i.join("")}const c=["float","vec2","vec3","vec4"];function d(){return h`
float range(float x, float y, float a) {
  return (a - x) / (y - x);
}
`}function u(){return h`
float cubicEaseInOut(float t) {
  return t < 0.5 ? 4.0 * t * t * t :
    4.0 * (t - 1.0) * (t - 1.0) * (t - 1.0) + 1.0;
}
`}function p(e="t",t="varyingT"){return c.map((i=>h`
${i} computeCurrentValue(
    ${i} startingValue,
    ${i} startingVelocity,
    ${i} targetValue) {
  ${i} currentValue = mix(startingValue, targetValue, ${t});
  ${i} projectedValue = startingVelocity *
    (targetTransitionTimeMs() - previousTransitionTimeMs());
  return currentValue + projectedValue *
    ${e} * (1. - ${e}) * (1. - ${e}) * (1. - ${e});
}
  `)).join("\n")}function f(){return h`
/**
 * @param positionWorld The position of the sprite in world coords.
 * @param size Size of the sprite in world coordinates.
 * @param positionRelative Offset position relative to vert coords.
 * @param positionPixel Offset position in screen pixels.
 * @param vertCoords Local coordinates for this vertex.
 * @param viewMatrix Matrix to project world coords into view space (pixels).
 */
vec2 computeViewVertexPosition(
    vec2 positionWorld,
    vec2 size,
    vec2 positionRelative,
    vec2 positionPixel,
    vec2 vertCoords,
    mat3 viewMatrix
) {
  vec2 vertexPositionWorld =
    positionWorld + size * (positionRelative + vertCoords);
  vec2 viewVertexPosition =
    (viewMatrix * vec3(vertexPositionWorld, 1.)).xy + positionPixel * 4.;
  return viewVertexPosition;
}
`}function g(){return h`
/**
 *
 * @param sizeWorld Size of the sprite in world coordinates.
 * @param sizePixel Offset size of the sprite in pixels.
 * @param geometricZoom The geometric zoom size modifier.
 * @param viewMatrixScale XY scale (world coords to pixels), and ZW inverse.
 * @param maxSizePixel Maximum allowed size in pixels.
 * @param minSizePixel Minimum allowed size in pixels.
 */
vec2 computeSize(
  vec2 sizeWorld,
  vec2 sizePixel,
  vec2 geometricZoom,
  vec4 viewMatrixScale,
  vec2 maxSizePixel,
  vec2 minSizePixel
) {
  // Combine scale with geometric zoom effect.
  vec2 zoomScale = exp(log(viewMatrixScale.xy) * (1. - geometricZoom));

  // Project the size in world coordinates to pixels to apply min/max.
  vec2 projectedSizePixel = sizeWorld * zoomScale +
    sizePixel * CLIP_SPACE_RANGE * devicePixelRatio;

  // Inital computed size in world coordinates is based on projected pixel size.
  vec2 computedSize = projectedSizePixel * viewMatrixScale.zw;

  // Compute whether max and min size components are positive, in parallel.
  // XY contains results for max, ZW contains results for min.
  bvec4 isPositive = greaterThan(vec4(maxSizePixel, minSizePixel), vec4(0.));

  // Apply maximums if set.
  bvec2 gtMax = greaterThan(projectedSizePixel, maxSizePixel);
  if (isPositive.x && gtMax.x) {
    computedSize.x = maxSizePixel.x * viewMatrixScale.z;
  }
  if (isPositive.y && gtMax.y) {
    computedSize.y = maxSizePixel.y * viewMatrixScale.w;
  }

  // Apply minimums if set.
  bvec2 ltMin = lessThan(projectedSizePixel, minSizePixel);
  if (isPositive.z && ltMin.x) {
    computedSize.x = minSizePixel.x * viewMatrixScale.z;
  }
  if (isPositive.w && ltMin.y) {
    computedSize.y = minSizePixel.y * viewMatrixScale.w;
  }

  return computedSize;
}
`}function x(){return h`
vec4 computeCurrentSizePixelAndWorld() {
  return computeCurrentValue(
    vec4(
      previousSizePixel(),
      previousSizeWorld()),
    vec4(
      previousSizePixelDelta(),
      previousSizeWorldDelta()),
    vec4(
      targetSizePixel(),
      targetSizeWorld())
  );
}
`}function v(){return h`
vec4 computeCurrentMaxAndMinSizePixel() {
  return computeCurrentValue(
    vec4(
      previousMaxSizePixel(),
      previousMinSizePixel()
    ),
    vec4(
      previousMaxSizePixelDelta(),
      previousMinSizePixelDelta()
    ),
    vec4(
      targetMaxSizePixel(),
      targetMinSizePixel()
    )
  ) * CLIP_SPACE_RANGE * devicePixelRatio;
}
`}function m(e){return h`
precision lowp float;

/**
 * WebGL vertex shaders output coordinates in clip space, which is a 3D volume
 * where each component is clipped to the range (-1,1). The distance from
 * edge-to-edge is therefore 2.
 */
const float CLIP_SPACE_RANGE = 2.;

/**
 * Each sprite receives the same vertex coordinates, which describe a unit
 * square centered at the origin. However, the distance calculations performed
 * by the fragment shader use a distance of 1 to mean the dead center of a
 * circle, which implies a diameter of 2. So to convert from sprite vertex
 * coordinate space to edge distance space requires a dilation of 2.
 */
const float EDGE_DISTANCE_DILATION = 2.;

/**
 * Current uniform timestamp for interpolating.
 */
uniform float ts;

/**
 * Effective devicePixelRatio.
 */
uniform float devicePixelRatio;

/**
 * Total number of sprite instances being rendered this pass. Used to compute
 * clip-space Z for stacking sprites based on their instanceIndex.
 * This ensures that partial-opacity pixels of stacked sprites will be
 * alpha-blended. Without this, occluded sprites' pixels may not blend.
 */
uniform float instanceCount;

/**
 * Granularity expected in the value of OrderZ values. The higher the
 * granularity, the more control the user has over the Z position of sprites.
 * However, this leaves less precision for correctly positioning sprites which
 * have exactly the same OrderZ value.
 */
uniform float orderZGranularity;

/**
 * View and projection matrices for converting from world space to clip space.
 */
uniform mat3 viewMatrix;
uniform mat3 projectionMatrix;

/**
 * Scale includes the X and Y dimensions of the viewMatrix, and their inverses
 * in the WZ components.
 */
uniform vec4 viewMatrixScale;

/**
 * Data textures holding the previous and target Sprite instance
 * attributes. The instantaneous value for each attribute is determined by
 * interpolating between the previous and target according to the ts uniform.
 */
uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

/**
 * Per-vertex coordinates for the quad into which the sprite will be rendered.
 * XY contain the local cartesian coordinates for a unit square centered at the
 * origin.
 *
 *   vertexCoordinates: [
 *     [-0.5, -0.5],
 *     [0.5, -0.5],
 *     [-0.5, 0.5],
 *     [0.5, 0.5],
 *   ],
 *
 */
attribute vec2 vertexCoordinates;

/**
 * Instanced, per-sprite index and UV coordinates of the sprite's data swatch.
 */
attribute float instanceIndex;
attribute vec2 instanceSwatchUv;

/**
 * Varying time value, eased using cubic-in-out between the previous and target
 * timestamps for this Sprite.
 */
varying float varyingT;

/**
 * Interpolated vertexCoordinates for fragment shader.
 */
varying vec2 varyingVertexCoordinates;

/**
 * Threshold distance values to consider the pixel outside the shape (X) or
 * inside the shape (Y). Values between constitute the border.
 */
varying vec2 varyingBorderThresholds;

/**
 * Scale value for converting edge distances to pixel distances in the fragment
 * shader.
 */
varying float varyingEdgeToPixelScale;

/**
 * Aspect ratio of the sprite's renderable area (XY) and their inverses (ZW).
 * One component of each pair will be 1. For the XY pair, the other component
 * be be greater than 1. and for the inverse pair it will be smaller.
 *
 * For example, a rectangle that's twice as wide as it is tall would have
 * varyingAspectRatio equal to vec4(2., 1., .5, 1.).
 */
varying vec4 varyingAspectRatio;

/**
 * Color attributes used by fragment shader.
 */
varying vec4 varyingBorderColor;
varying vec4 varyingFillColor;

/**
 * Shape attributes used by fragment shader.
 */
varying float varyingPreviousSides;
varying float varyingTargetSides;
varying vec4 varyingPreviousShapeTexture;
varying vec4 varyingTargetShapeTexture;

// Import utility shader functions.
${d()}
${u()}

// These arrays are filled in by code generated by the AttributeMapper.
vec4 previousTexelValues[${e.texelsPerSwatch}];
vec4 targetTexelValues[${e.texelsPerSwatch}];

/**
 * Read data texel values into the previous and target arrays.
 */
void readTexels() {
    ${e.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","instanceSwatchUv")}
    ${e.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","instanceSwatchUv")}
}

// Dynamically generate #DEFINE statements to access texel attributes by name.
// These look like method invocations elsewhere in the code. For example, the
// define "targetTransitionTimeMs()" extracts the float value
// targetTexelValues[0].r.
${e.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${e.generateAttributeDefinesGLSL("target","targetTexelValues")}

/**
 * Local, non-eased, normalized time value between 0 and 1, computed between the
 * previous and target timestamp according to the uniform ts.
 */
float t;

${p()}

/**
 * Precomputed constant value for converting colors in the 0-255 RGB range to
 * the GL standard 0-1 range. (1 / 255 = 0.00392156862745098)
 */
const vec4 GL_COLOR = vec4(vec3(0.00392156862745098), 1.);

/**
 * Function to compute all the varying values needed by the fragment shader.
 */
void setupVaryings() {
  // Clamp and range t value within previous and target timestamps.
  t =
    ts >= targetTransitionTimeMs() ? 1. :
    ts <= previousTransitionTimeMs() ? 0. :
    clamp(range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
        0., 1.);

  // Compute eased varyingT.
  varyingT = cubicEaseInOut(t);

  // Copy and interpolate vertex coordinate values.
  varyingVertexCoordinates = vertexCoordinates;

  // Copy previous and target shape attributes.
  varyingPreviousSides = previousSides();
  varyingPreviousShapeTexture = previousShapeTexture();
  varyingTargetSides = targetSides();
  varyingTargetShapeTexture = targetShapeTexture();

  // Compute color attributes.
  varyingBorderColor = computeCurrentValue(
    previousBorderColor(),
    previousBorderColorDelta(),
    targetBorderColor()) * GL_COLOR;
  varyingFillColor = computeCurrentValue(
    previousFillColor(),
    previousFillColorDelta(),
    targetFillColor()) * GL_COLOR;
}

${h`
/**
 * @param size The size of the sprite.
 * @return The aspect ratio (XY) and the inverse of the aspect ratio (ZW).
 */
vec4 computeAspectRatio(vec2 size) {
  vec2 ar = size / min(size.x, size.y);
  return vec4(ar, 1. / ar);
}
`}
${v()}
${x()}
${g()}
${f()}

void main () {

  // Read data values from previous and target data textures.
  readTexels();

  // Setup varying values used both here and by the fragment shader.
  setupVaryings();

  // Compute current size component values by interpolation (parallelized).
  vec4 currentSizePixelAndWorld = computeCurrentSizePixelAndWorld();
  vec2 currentSizePixel = currentSizePixelAndWorld.xy;
  vec2 currentSizeWorld = currentSizePixelAndWorld.zw;

  vec2 currentGeometricZoom = computeCurrentValue(
      previousGeometricZoom(),
      previousGeometricZoomDelta(),
      targetGeometricZoom()
  );

  vec4 currentMaxAndMinSizePixel = computeCurrentMaxAndMinSizePixel();
  vec2 currentMaxSizePixel = currentMaxAndMinSizePixel.xy;
  vec2 currentMinSizePixel = currentMaxAndMinSizePixel.zw;

  // Compute the current size of the sprite in world units, including the effect
  // of geometric zoom and applying min and max pixel sizes.
  vec2 computedSize = computeSize(
    currentSizeWorld,
    currentSizePixel,
    currentGeometricZoom,
    viewMatrixScale,
    currentMaxSizePixel,
    currentMinSizePixel
  );

  // Compute border attributes in parallel.
  vec3 borderProperties = computeCurrentValue(
      vec3(
        previousBorderRadiusPixel(),
        previousBorderRadiusRelative(),
        previousBorderPlacement()),
      vec3(
        previousBorderRadiusPixelDelta(),
        previousBorderRadiusRelativeDelta(),
        previousBorderPlacementDelta()),
      vec3(
        targetBorderRadiusPixel(),
        targetBorderRadiusRelative(),
        targetBorderPlacement())
  );
  float currentBorderRadiusPixel = borderProperties.x;
  float currentBorderRadiusRelative = borderProperties.y;
  float currentBorderPlacement = borderProperties.z;

  // Project the computed size into pixels by using the viewMatrixScale. Note
  // that this already includes the effect of the devicePixelRatio, and a 2x
  // multiplier for clip-space, which goes from -1 to 1 in all dimensions.
  vec2 projectedSizePixel = computedSize.xy * viewMatrixScale.xy;

  varyingEdgeToPixelScale =
    CLIP_SPACE_RANGE * EDGE_DISTANCE_DILATION /
    min(projectedSizePixel.x, projectedSizePixel.y);

  // The fragment shader needs to know the threshold signed distances that
  // indicate whether each pixel is inside the shape, in the border, or outside
  // of the shape. A point right on the edge of the shape will have a distance
  // of 0. In edge-distance space, a distance of 1 would be the dead center of a
  // circle.
  float edgeDistance = currentBorderRadiusRelative +
    currentBorderRadiusPixel * varyingEdgeToPixelScale * devicePixelRatio;
  varyingBorderThresholds =
    vec2(0., edgeDistance) - edgeDistance * currentBorderPlacement;

  // Shift the quad vertices outward to account for borders, which may expand
  // the bounding box of the sprite.
  varyingVertexCoordinates *= (1. - varyingBorderThresholds.x);

  // Compute the sprite's aspect ratio and the inverse.
  varyingAspectRatio = computeAspectRatio(projectedSizePixel);

  // Compute the current position component attributes.
  vec2 currentPositionPixel = computeCurrentValue(
      previousPositionPixel(),
      previousPositionPixelDelta(),
      targetPositionPixel());

  vec2 currentPositionWorld = computeCurrentValue(
      previousPositionWorld(),
      previousPositionWorldDelta(),
      targetPositionWorld());

  vec2 currentPositionRelative = computeCurrentValue(
      previousPositionRelative(),
      previousPositionRelativeDelta(),
      targetPositionRelative());

  // Project the world position into pixel space, then add the pixel component.
  vec2 viewVertexPosition = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      varyingVertexCoordinates,
      viewMatrix
  );

  // Project the pixel space coordinate into clip space.
  vec2 clipVertexPosition =
    (projectionMatrix * vec3(viewVertexPosition, 1.)).xy;

  // Compute the current user-specified OrderZ value.
  float currentOrderZ = computeCurrentValue(
      previousOrderZ(),
      previousOrderZDelta(),
      targetOrderZ());

  // Compute the stacking Z value for index-order blending.
  float stackZ = (1. + instanceIndex) / (1. + instanceCount);

  // Use provided granularity to combine current and stack Z values.
  float gInv = 1. / orderZGranularity;

  float combinedZ =
    mix(0., 1. - gInv, currentOrderZ) +
    mix(0., gInv, stackZ);

  // Project combined Z into clip space.
  float clipZ = mix(1., -1., combinedZ);

  gl_Position = vec4(clipVertexPosition, clipZ, 1.);
}
`}function w(e){return h`
precision lowp float;

attribute vec2 vertexCoordinates;

attribute vec2 instanceRebaseUv;

#define TEXELS_PER_SWATCH ${e.texelsPerSwatch}.
#define TEXTURE_WIDTH ${e.textureWidth}.
#define TEXTURE_HEIGHT ${e.textureHeight}.

varying vec2 varyingRebaseUv;
varying float varyingTexelIndex;

const vec2 swatchSize =
  vec2(TEXELS_PER_SWATCH / TEXTURE_WIDTH, 1. / TEXTURE_HEIGHT);

void main () {
  varyingRebaseUv = instanceRebaseUv;
  varyingTexelIndex = (vertexCoordinates.x + .5) * TEXELS_PER_SWATCH - .5;
  vec2 swatchUv = instanceRebaseUv + (vertexCoordinates.xy + .5) * swatchSize;
  gl_Position = vec4(2. * swatchUv - 1., 0., 1.);
}
`}const b=Object.freeze({requestAnimationFrame:e=>window.requestAnimationFrame(e),cancelAnimationFrame:e=>{window.cancelAnimationFrame(e)},now:()=>Date.now()}),T=1e20;class y{constructor(e=24,t=3,i=8,r=.25,a="sans-serif",s="normal"){this.fontSize=e,this.buffer=t,this.radius=i,this.cutoff=r,this.fontFamily=a,this.fontWeight=s;const n=this.size=this.fontSize+2*this.buffer;this.canvas=document.createElement("canvas"),this.canvas.width=this.canvas.height=n;const o=this.canvas.getContext("2d");if(!o)throw new Error("Could not get canvas 2d context");this.ctx=o,this.ctx.font=`${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`,this.ctx.textBaseline="middle",this.ctx.fillStyle="black",this.gridOuter=new Float64Array(n*n),this.gridInner=new Float64Array(n*n),this.f=new Float64Array(n),this.z=new Float64Array(n+1),this.v=new Uint16Array(n),this.middle=Math.round(n/2*(navigator.userAgent.indexOf("Gecko/")>=0?1.2:1))}draw(e){this.ctx.clearRect(0,0,this.size,this.size),this.ctx.fillText(e,this.buffer,this.middle);const t=this.ctx.getImageData(0,0,this.size,this.size);return function({imgData:e,size:t,radius:i,cutoff:r,gridOuter:a,gridInner:s,f:n,v:o,z:l}){const h=new Uint8ClampedArray(t*t);for(let i=0;i<t*t;i++){const t=e.data[4*i+3]/255;a[i]=1===t?0:0===t?T:Math.pow(Math.max(0,.5-t),2),s[i]=1===t?T:0===t?0:Math.pow(Math.max(0,t-.5),2)}S(a,t,t,n,o,l),S(s,t,t,n,o,l);for(let e=0;e<t*t;e++){const t=Math.sqrt(a[e])-Math.sqrt(s[e]);h[e]=Math.round(255-255*(t/i+r))}return h}(Object.assign(Object.assign({},this),{imgData:t}))}}function S(e,t,i,r,a,s){R(e,t,i,r,a,s),P(e,t,i,r,a,s)}function P(e,t,i,r,a,s){for(let n=0;n<i;n++)C(e,n*t,1,t,r,a,s)}function R(e,t,i,r,a,s){for(let n=0;n<t;n++)C(e,n,t,i,r,a,s)}function C(e,t,i,r,a,s,n){let o,l,h,c;for(s[0]=0,n[0]=-T,n[1]=T,o=0;o<r;o++)a[o]=e[t+o*i];for(o=1,l=0,h=0;o<r;o++){do{c=s[l],h=(a[o]-a[c]+o*o-c*c)/(o-c)/2}while(h<=n[l]&&--l>-1);l++,s[l]=o,n[l]=h,n[l+1]=T}for(o=0,l=0;o<r;o++){for(;n[l+1]<o;)l++;c=s[l],e[t+o*i]=a[c]+(o-c)*(o-c)}}const k=Object.freeze({maxTextureSize:2048,fontSize:32,buffer:32,radius:32,cutoff:1,fontFamily:"monospace",fontWeight:"normal"});class z{constructor(e=k){this.glyphToCoordinates=new Map;const t=Object.assign({},k,e||{});this.maxTextureSize=t.maxTextureSize,this.tinySDF=new y(t.fontSize,t.buffer,t.radius,t.cutoff,t.fontFamily,t.fontWeight),this.glyphSize=this.tinySDF.size,this.glyphsPerRow=Math.floor(this.maxTextureSize/this.glyphSize),this.glyphCapacity=this.glyphsPerRow*this.glyphsPerRow,this.textureSize=this.glyphsPerRow*this.glyphSize,this.textureData=new Float32Array(this.textureSize*this.textureSize)}hasGlyph(e){return this.glyphToCoordinates.has(e)}getGlyph(e){return this.glyphToCoordinates.get(e)}addGlyph(e){const t=this.getGlyph(e);if(t)return t;const i=this.glyphToCoordinates.size;if(i>=this.glyphCapacity)throw new Error("Cannot add glyph, already at capacity");const r=Math.floor(i/this.glyphsPerRow),a=i%this.glyphsPerRow,s=r*this.glyphSize*this.textureSize+a*this.glyphSize,{canvas:n,ctx:o,size:l,buffer:h,middle:c,radius:d,cutoff:u}=this.tinySDF;o.clearRect(0,0,l,l),o.fillText(e,h,c);const p=function(e,t,i=.5){const{width:r,height:a}=e,s=e.getContext("2d");if(!s)throw new Error("Could not get canvas 2d context");const n=s.getImageData(0,0,r,a),o=new Float64Array(r*a),l=new Float64Array(r*a),h=new Float64Array(r*a),c=new Float64Array(r*a),d=new Float64Array(r*a),u=new Float64Array(r*a),p=new Float64Array(r),f=new Float64Array(r+1),g=new Uint16Array(r);for(let e=0;e<r*a;e++){const t=n.data[4*e+3]/255;d[e]=h[e]=o[e]=1===t?0:0===t?T:Math.pow(Math.max(0,.5-t),2),u[e]=c[e]=l[e]=1===t?T:0===t?0:Math.pow(Math.max(0,t-.5),2)}S(d,r,a,p,g,f),S(u,r,a,p,g,f),P(o,r,a,p,g,f),P(l,r,a,p,g,f),R(h,r,a,p,g,f),R(c,r,a,p,g,f);const x=new Float32Array(r*a*3);for(let e=0;e<r*a;e++)x[3*e]=Math.max(0,1-((Math.sqrt(o[e])-Math.sqrt(l[e]))/t+i)),x[3*e+1]=Math.max(0,1-((Math.sqrt(h[e])-Math.sqrt(c[e]))/t+i)),x[3*e+2]=1-((Math.sqrt(d[e])-Math.sqrt(u[e]))/t+i);return x}(n,d,u);for(let e=0;e<this.glyphSize;e++)for(let t=0;t<this.glyphSize;t++){const i=3*(e*this.glyphSize+t)+2,r=s+e*this.textureSize+t;this.textureData[r]=p[i]}const f=Object.freeze({u:a/this.glyphsPerRow,v:r/this.glyphsPerRow,width:this.glyphSize/this.textureSize,height:this.glyphSize/this.textureSize});return this.glyphToCoordinates.set(e,f),f}get glyphs(){return[...this.glyphToCoordinates.keys()]}}const N=Object.freeze({antialiasingFactor:.5,container:document.body,defaultTransitionTimeMs:250,desiredSpriteCapacity:1e6,devicePixelRatio:void 0,glyphs:"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}",glyphMapper:k,orderZGranularity:10,timingFunctions:b}),I=Symbol("internalProperties"),M=Symbol("dataView"),B=Symbol("sceneInternal");class V{constructor(e){this[M]=e}get TransitionTimeMs(){return this[M][0]}set TransitionTimeMs(e){if(isNaN(e))throw new RangeError("TransitionTimeMs cannot be NaN");this[M][0]=e}get PositionWorldX(){return this[M][1]}set PositionWorldX(e){if(isNaN(e))throw new RangeError("PositionWorldX cannot be NaN");this[M][1]=e}get PositionWorldY(){return this[M][2]}set PositionWorldY(e){if(isNaN(e))throw new RangeError("PositionWorldY cannot be NaN");this[M][2]=e}get SizeWorldWidth(){return this[M][3]}set SizeWorldWidth(e){if(isNaN(e))throw new RangeError("SizeWorldWidth cannot be NaN");this[M][3]=e}get SizeWorldHeight(){return this[M][4]}set SizeWorldHeight(e){if(isNaN(e))throw new RangeError("SizeWorldHeight cannot be NaN");this[M][4]=e}get OrderZ(){return this[M][5]}set OrderZ(e){if(isNaN(e))throw new RangeError("OrderZ cannot be NaN");if(e<0)throw new RangeError("OrderZ cannot be less than 0");if(e>1)throw new RangeError("OrderZ cannot be greater than 1");this[M][5]=e}get GeometricZoomX(){return this[M][6]}set GeometricZoomX(e){if(isNaN(e))throw new RangeError("GeometricZoomX cannot be NaN");this[M][6]=e}get GeometricZoomY(){return this[M][7]}set GeometricZoomY(e){if(isNaN(e))throw new RangeError("GeometricZoomY cannot be NaN");this[M][7]=e}get PositionPixelX(){return this[M][8]}set PositionPixelX(e){if(isNaN(e))throw new RangeError("PositionPixelX cannot be NaN");this[M][8]=e}get PositionPixelY(){return this[M][9]}set PositionPixelY(e){if(isNaN(e))throw new RangeError("PositionPixelY cannot be NaN");this[M][9]=e}get SizePixelWidth(){return this[M][10]}set SizePixelWidth(e){if(isNaN(e))throw new RangeError("SizePixelWidth cannot be NaN");this[M][10]=e}get SizePixelHeight(){return this[M][11]}set SizePixelHeight(e){if(isNaN(e))throw new RangeError("SizePixelHeight cannot be NaN");this[M][11]=e}get MaxSizePixelWidth(){return this[M][12]}set MaxSizePixelWidth(e){if(isNaN(e))throw new RangeError("MaxSizePixelWidth cannot be NaN");this[M][12]=e}get MaxSizePixelHeight(){return this[M][13]}set MaxSizePixelHeight(e){if(isNaN(e))throw new RangeError("MaxSizePixelHeight cannot be NaN");this[M][13]=e}get MinSizePixelWidth(){return this[M][14]}set MinSizePixelWidth(e){if(isNaN(e))throw new RangeError("MinSizePixelWidth cannot be NaN");this[M][14]=e}get MinSizePixelHeight(){return this[M][15]}set MinSizePixelHeight(e){if(isNaN(e))throw new RangeError("MinSizePixelHeight cannot be NaN");this[M][15]=e}get PositionRelativeX(){return this[M][16]}set PositionRelativeX(e){if(isNaN(e))throw new RangeError("PositionRelativeX cannot be NaN");this[M][16]=e}get PositionRelativeY(){return this[M][17]}set PositionRelativeY(e){if(isNaN(e))throw new RangeError("PositionRelativeY cannot be NaN");this[M][17]=e}get Sides(){return this[M][18]}set Sides(e){if(isNaN(e))throw new RangeError("Sides cannot be NaN");this[M][18]=e}get ShapeTextureU(){return this[M][19]}set ShapeTextureU(e){if(isNaN(e))throw new RangeError("ShapeTextureU cannot be NaN");this[M][19]=e}get ShapeTextureV(){return this[M][20]}set ShapeTextureV(e){if(isNaN(e))throw new RangeError("ShapeTextureV cannot be NaN");this[M][20]=e}get ShapeTextureWidth(){return this[M][21]}set ShapeTextureWidth(e){if(isNaN(e))throw new RangeError("ShapeTextureWidth cannot be NaN");this[M][21]=e}get ShapeTextureHeight(){return this[M][22]}set ShapeTextureHeight(e){if(isNaN(e))throw new RangeError("ShapeTextureHeight cannot be NaN");this[M][22]=e}get BorderRadiusPixel(){return this[M][23]}set BorderRadiusPixel(e){if(isNaN(e))throw new RangeError("BorderRadiusPixel cannot be NaN");this[M][23]=e}get BorderRadiusRelative(){return this[M][24]}set BorderRadiusRelative(e){if(isNaN(e))throw new RangeError("BorderRadiusRelative cannot be NaN");this[M][24]=e}get BorderPlacement(){return this[M][25]}set BorderPlacement(e){if(isNaN(e))throw new RangeError("BorderPlacement cannot be NaN");this[M][25]=e}get BorderColorR(){return this[M][26]}set BorderColorR(e){if(isNaN(e))throw new RangeError("BorderColorR cannot be NaN");this[M][26]=e}get BorderColorG(){return this[M][27]}set BorderColorG(e){if(isNaN(e))throw new RangeError("BorderColorG cannot be NaN");this[M][27]=e}get BorderColorB(){return this[M][28]}set BorderColorB(e){if(isNaN(e))throw new RangeError("BorderColorB cannot be NaN");this[M][28]=e}get BorderColorOpacity(){return this[M][29]}set BorderColorOpacity(e){if(isNaN(e))throw new RangeError("BorderColorOpacity cannot be NaN");this[M][29]=e}get FillColorR(){return this[M][30]}set FillColorR(e){if(isNaN(e))throw new RangeError("FillColorR cannot be NaN");this[M][30]=e}get FillColorG(){return this[M][31]}set FillColorG(e){if(isNaN(e))throw new RangeError("FillColorG cannot be NaN");this[M][31]=e}get FillColorB(){return this[M][32]}set FillColorB(e){if(isNaN(e))throw new RangeError("FillColorB cannot be NaN");this[M][32]=e}get FillColorOpacity(){return this[M][33]}set FillColorOpacity(e){if(isNaN(e))throw new RangeError("FillColorOpacity cannot be NaN");this[M][33]=e}set PositionWorld(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionWorldX=e[0],t=!0),"1"in e&&(this.PositionWorldY=e[1],t=!0),!t)throw new TypeError("No PositionWorld component index values were found")}else{if("object"!=typeof e)throw new TypeError("PositionWorld setter argument must be an array or object");{let t=!1;if("x"in e&&(this.PositionWorldX=e.x,t=!0),"y"in e&&(this.PositionWorldY=e.y,t=!0),!t)throw new TypeError("No PositionWorld component key values were found")}}}set SizeWorld(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.SizeWorldWidth=e[0],t=!0),"1"in e&&(this.SizeWorldHeight=e[1],t=!0),!t)throw new TypeError("No SizeWorld component index values were found")}else if("object"!=typeof e)this.SizeWorldWidth=e,this.SizeWorldHeight=e;else{let t=!1;if("width"in e&&(this.SizeWorldWidth=e.width,t=!0),"height"in e&&(this.SizeWorldHeight=e.height,t=!0),!t)throw new TypeError("No SizeWorld component key values were found")}}set GeometricZoom(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.GeometricZoomX=e[0],t=!0),"1"in e&&(this.GeometricZoomY=e[1],t=!0),!t)throw new TypeError("No GeometricZoom component index values were found")}else if("object"!=typeof e)this.GeometricZoomX=e,this.GeometricZoomY=e;else{let t=!1;if("x"in e&&(this.GeometricZoomX=e.x,t=!0),"y"in e&&(this.GeometricZoomY=e.y,t=!0),!t)throw new TypeError("No GeometricZoom component key values were found")}}set PositionPixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionPixelX=e[0],t=!0),"1"in e&&(this.PositionPixelY=e[1],t=!0),!t)throw new TypeError("No PositionPixel component index values were found")}else{if("object"!=typeof e)throw new TypeError("PositionPixel setter argument must be an array or object");{let t=!1;if("x"in e&&(this.PositionPixelX=e.x,t=!0),"y"in e&&(this.PositionPixelY=e.y,t=!0),!t)throw new TypeError("No PositionPixel component key values were found")}}}set SizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.SizePixelWidth=e[0],t=!0),"1"in e&&(this.SizePixelHeight=e[1],t=!0),!t)throw new TypeError("No SizePixel component index values were found")}else if("object"!=typeof e)this.SizePixelWidth=e,this.SizePixelHeight=e;else{let t=!1;if("width"in e&&(this.SizePixelWidth=e.width,t=!0),"height"in e&&(this.SizePixelHeight=e.height,t=!0),!t)throw new TypeError("No SizePixel component key values were found")}}set MaxSizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.MaxSizePixelWidth=e[0],t=!0),"1"in e&&(this.MaxSizePixelHeight=e[1],t=!0),!t)throw new TypeError("No MaxSizePixel component index values were found")}else if("object"!=typeof e)this.MaxSizePixelWidth=e,this.MaxSizePixelHeight=e;else{let t=!1;if("width"in e&&(this.MaxSizePixelWidth=e.width,t=!0),"height"in e&&(this.MaxSizePixelHeight=e.height,t=!0),!t)throw new TypeError("No MaxSizePixel component key values were found")}}set MinSizePixel(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.MinSizePixelWidth=e[0],t=!0),"1"in e&&(this.MinSizePixelHeight=e[1],t=!0),!t)throw new TypeError("No MinSizePixel component index values were found")}else if("object"!=typeof e)this.MinSizePixelWidth=e,this.MinSizePixelHeight=e;else{let t=!1;if("width"in e&&(this.MinSizePixelWidth=e.width,t=!0),"height"in e&&(this.MinSizePixelHeight=e.height,t=!0),!t)throw new TypeError("No MinSizePixel component key values were found")}}set PositionRelative(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.PositionRelativeX=e[0],t=!0),"1"in e&&(this.PositionRelativeY=e[1],t=!0),!t)throw new TypeError("No PositionRelative component index values were found")}else{if("object"!=typeof e)throw new TypeError("PositionRelative setter argument must be an array or object");{let t=!1;if("x"in e&&(this.PositionRelativeX=e.x,t=!0),"y"in e&&(this.PositionRelativeY=e.y,t=!0),!t)throw new TypeError("No PositionRelative component key values were found")}}}set ShapeTexture(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.ShapeTextureU=e[0],t=!0),"1"in e&&(this.ShapeTextureV=e[1],t=!0),"2"in e&&(this.ShapeTextureWidth=e[2],t=!0),"3"in e&&(this.ShapeTextureHeight=e[3],t=!0),!t)throw new TypeError("No ShapeTexture component index values were found")}else{if("object"!=typeof e)throw new TypeError("ShapeTexture setter argument must be an array or object");{let t=!1;if("u"in e&&(this.ShapeTextureU=e.u,t=!0),"v"in e&&(this.ShapeTextureV=e.v,t=!0),"width"in e&&(this.ShapeTextureWidth=e.width,t=!0),"height"in e&&(this.ShapeTextureHeight=e.height,t=!0),!t)throw new TypeError("No ShapeTexture component key values were found")}}}set BorderColor(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.BorderColorR=e[0],t=!0),"1"in e&&(this.BorderColorG=e[1],t=!0),"2"in e&&(this.BorderColorB=e[2],t=!0),"3"in e&&(this.BorderColorOpacity=e[3],t=!0),!t)throw new TypeError("No BorderColor component index values were found")}else{if("object"!=typeof e)throw new TypeError("BorderColor setter argument must be an array or object");{let t=!1;if("r"in e&&(this.BorderColorR=e.r,t=!0),"g"in e&&(this.BorderColorG=e.g,t=!0),"b"in e&&(this.BorderColorB=e.b,t=!0),"opacity"in e&&(this.BorderColorOpacity=e.opacity,t=!0),!t)throw new TypeError("No BorderColor component key values were found")}}}set FillColor(e){if(Array.isArray(e)){let t=!1;if("0"in e&&(this.FillColorR=e[0],t=!0),"1"in e&&(this.FillColorG=e[1],t=!0),"2"in e&&(this.FillColorB=e[2],t=!0),"3"in e&&(this.FillColorOpacity=e[3],t=!0),!t)throw new TypeError("No FillColor component index values were found")}else{if("object"!=typeof e)throw new TypeError("FillColor setter argument must be an array or object");{let t=!1;if("r"in e&&(this.FillColorR=e.r,t=!0),"g"in e&&(this.FillColorG=e.g,t=!0),"b"in e&&(this.FillColorB=e.b,t=!0),"opacity"in e&&(this.FillColorOpacity=e.opacity,t=!0),!t)throw new TypeError("No FillColor component key values were found")}}}}class D extends Error{}var A;function E(e,t){return e===t?NaN:1<<5*e+t-+(t>e)}!function(e){e[e.Created=0]="Created",e[e.Rest=1]="Rest",e[e.HasCallback=2]="HasCallback",e[e.NeedsRebase=3]="NeedsRebase",e[e.NeedsTextureSync=4]="NeedsTextureSync",e[e.Removed=5]="Removed"}(A||(A={}));const W=function(){const{Created:e,Rest:t,HasCallback:i,NeedsRebase:r,NeedsTextureSync:a,Removed:s}=A;let n=0;return n|=E(e,t),n|=E(e,s),n|=E(t,i),n|=E(t,a),n|=E(i,r),n|=E(i,a),n|=E(r,a),n|=E(a,t),n|=E(a,i),n|=E(a,s),n}();class F{constructor(){this.isDefined=!1,this.lowBound=NaN,this.highBound=NaN}clear(){this.isDefined=!1,this.lowBound=NaN,this.highBound=NaN}expandToInclude(e){if(!this.isDefined)return this.lowBound=e,this.highBound=e,void(this.isDefined=!0);e<this.lowBound&&(this.lowBound=e),e>this.highBound&&(this.highBound=e)}truncateToWithin(e,t){if(isNaN(+e)||isNaN(+t))throw new RangeError("Both values must be numbers");if(t<e)throw new RangeError("High bound must be greater than or equal to low bound");this.isDefined&&(e>this.highBound||t<this.lowBound?this.clear():(this.lowBound<e&&(this.lowBound=e),this.highBound>t&&(this.highBound=t)))}overlaps(e){return this.isDefined&&e.isDefined&&this.lowBound<=e.highBound&&this.highBound>=e.lowBound}}var $;!function(e){e[e.None=0]="None",e[e.Blocked=1]="Blocked",e[e.Scheduled=2]="Scheduled",e[e.Started=3]="Started"}($||($={}));class H{constructor(e,t){this.stepsBetweenChecks=e,this.coordinator=t,this.sprites=[],this.boundData=[],this.bindingState=$.None,this.hasWarned=!1,this.bindingTaskId=Symbol("bindingTask"),this.clearingTaskId=Symbol("clearingTask")}onInit(e){return this.onInitCallback=e,this}onEnter(e){return this.onEnterCallback=e,this}onUpdate(e){return this.onUpdateCallback=e,this}onExit(e){return this.onExitCallback=e,this}bind(e,t){if(t)throw new Error("keyFn mapping is not yet supported");if(this.hasWarned||this.bindingState!==$.Scheduled||(console.warn("Possibly conflicting .bind() invocations detected"),this.hasWarned=!0),this.clearingTask)return this.bindingState=$.Blocked,this.coordinator.workScheduler.scheduleUniqueTask({id:this.bindingTaskId,callback:()=>{this.bindingState=$.None,this.bind(e,t)}}),this;let i=0;const r=e.length;let a=this.boundData.length;const{onInitCallback:s,onEnterCallback:n,onUpdateCallback:o,onExitCallback:l}=this,h=t=>{for(;a<r;){i++;const r=a++,o=e[r],l=this.coordinator.createSprite();if(this.boundData[r]=o,this.sprites[r]=l,s&&l.enter((e=>{s(e,o),e.TransitionTimeMs=0})),n&&l.update((e=>{n(e,o)})),i%this.stepsBetweenChecks==0&&t()<=0)break}return a>=r};let c=0;const d=Math.min(r,this.boundData.length),u=t=>{for(;c<d;){i++;const r=c++,a=e[r],s=this.sprites[r];if(this.boundData[r]=a,o&&s.update((e=>{o(e,a)})),i%this.stepsBetweenChecks==0&&t()<=0)break}return c>=d},p=e=>{let t=r;for(;t<this.boundData.length;){i++;const r=this.boundData[t],a=this.sprites[t];if(t++,a.isAbandoned||a.isActive||a.isRemoved?a.exit((e=>{l&&l(e,r)})):a.abandon(),i%this.stepsBetweenChecks==0&&e()<=0)break}return t>r&&(this.boundData.splice(r,t-r),this.sprites.splice(r,t-r)),this.boundData.length<=r};return this.bindingTask={id:this.bindingTaskId,callback:e=>{this.bindingState=$.Started,i=0;const t=p(e)&&u(e)&&h(e);return t&&(delete this.bindingTask,this.bindingState=$.None),t},runUntilDone:!0},this.coordinator.workScheduler.scheduleUniqueTask(this.bindingTask),this.bindingState=$.Scheduled,this}clear(){let e=0;const{onExitCallback:t}=this,i=i=>{let r=0;for(;r<this.boundData.length;){e++;const a=this.boundData[r],s=this.sprites[r];if(r++,s.isAbandoned||s.isActive||s.isRemoved?s.exit((e=>{t&&t(e,a)})):s.abandon(),e%this.stepsBetweenChecks==0&&i()<=0)break}return this.boundData.splice(0,r),this.sprites.splice(0,r),!this.boundData.length};return this.clearingTask={id:this.clearingTaskId,callback:t=>{e=0;const r=i(t);return r&&delete this.clearingTask,r},runUntilDone:!0},this.bindingTask&&(this.coordinator.workScheduler.unscheduleTask(this.bindingTask),delete this.bindingTask),this.coordinator.workScheduler.scheduleUniqueTask(this.clearingTask),this.bindingState=$.None,this}hitTest(e){const t=this.coordinator.hitTest(Object.assign(Object.assign({},e),{sprites:this.sprites})),i=new Uint32Array(t.length);let r=0;for(let e=0;e<t.length;e++){t[e]>=0&&(i[r++]=e)}if(!r)return[];(void 0===e.sortResults||e.sortResults)&&i.subarray(0,r).sort(((e,i)=>t[e]-t[i]));const a=new Array(r);for(let e=0;e<r;e++)a[e]=this.boundData[i[e]];return a}}class U{constructor(){this.internalLifecyclePhase=A.Created}get hasCallback(){return!!(this.enterCallback||this.updateCallback||this.exitCallback)}get lifecyclePhase(){return this.internalLifecyclePhase}set lifecyclePhase(e){!function(e,t){if(!(E(e,t)&W))throw new D("Illegal sprite lifecycle phase transition")}(this.internalLifecyclePhase,e),this.internalLifecyclePhase=e}}class G{constructor(e){this.coordinator=e,this[I]=new U}enter(e){if(this.isAbandoned)throw new Error("Cannot add enter callback to abandoned sprite");if(this.isRemoved)throw new Error("Cannot add enter callback to Removed sprite");const t=this[I];if(t.enterCallback=e,t.lifecyclePhase===A.Rest){if(void 0===t.index)throw new D("Sprite lacks index");this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=A.HasCallback}return this}update(e){if(this.isAbandoned)throw new Error("Cannot add update callback to abandoned sprite");if(this.isRemoved)throw new Error("Cannot add update callback to Removed sprite");const t=this[I];if(t.updateCallback=e,t.lifecyclePhase===A.Rest){if(void 0===t.index)throw new D("Sprite lacks index");this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=A.HasCallback}return this}exit(e){if(this.isAbandoned)throw new Error("Cannot add exit callback to abandoned sprite");if(this.isRemoved)throw new Error("Cannot add exit callback to Removed sprite");const t=this[I];if(t.exitCallback=e,t.toBeRemoved=!0,t.lifecyclePhase===A.Rest){if(void 0===t.index)throw new D("Sprite lacks index");this.coordinator.markSpriteCallback(t.index),t.lifecyclePhase=A.HasCallback}return this}abandon(){if(this.isAbandoned)throw new Error("Cannot abandon a Sprite already marked abandoned");if(this.isRemoved)throw new Error("Cannot abandon a Sprite that has been removed");if(this.isActive)throw new Error("Cannot abandon an active Sprite");const e=this[I];e.isAbandoned=!0,e.enterCallback=void 0,e.updateCallback=void 0,e.exitCallback=void 0,e.toBeRemoved=!0,e.lifecyclePhase=A.Removed}get isActive(){const e=this[I].lifecyclePhase;return e!==A.Created&&e!==A.Removed}get isAbandoned(){return!!this[I].isAbandoned}get isRemoved(){return this[I].lifecyclePhase===A.Removed}}function O(e,t){const i=new F;if(!e.isDefined)return i;const{lowBound:r,highBound:a}=e,s=Math.floor(r/t),n=Math.floor(a/t)+1;return i.expandToInclude(s*t),i.expandToInclude(n*t-1),i}const L="center",j="middle";function q(e,t){e.Sides=0,e.ShapeTexture=t.coords,e.PositionRelative=t.position}class _{constructor(e,t,i,r){this.stepsBetweenChecks=e,this.renderer=t,this.workScheduler=i,this.glyphMapper=r,this.selections=[],this.boundData=[],this.bindingTaskId=Symbol("bindingTask"),this.clearingTaskId=Symbol("clearingTask"),this.textCallback=e=>`${e}`,this.alignCallback=()=>L,this.verticalAlignCallback=()=>j}text(e){return this.textCallback=e,this}align(e){return this.alignCallback=e,this}verticalAlign(e){return this.verticalAlignCallback=e,this}onInit(e){return this.initCallback=e,this}onEnter(e){return this.enterCallback=e,this}onUpdate(e){return this.updateCallback=e,this}onExit(e){return this.exitCallback=e,this}bind(e,t){if(t)throw new Error("keyFn mapping is not yet supported");if(this.clearingTask)return this.workScheduler.scheduleUniqueTask({id:this.bindingTaskId,callback:()=>this.bind(e,t)}),this;let i=0;const r=e.length;let a=this.boundData.length;const{textCallback:s,alignCallback:n,verticalAlignCallback:o}=this,l=e=>{const t=(s?s(e):`${e}`).trim(),i=n&&n(e)||L,r=o&&o(e)||j,a=[];for(let s=0;s<t.length;s++){let n,o;n="left"===i?.5*(s+1):"right"===i?.5*(s+1-t.length):.5*(s+.75-.5*t.length),o="top"===r?-.5:"bottom"===r?.5:0;const l=this.glyphMapper.getGlyph(t.charAt(s));l&&a.push({datum:e,coords:l,position:{x:n,y:o}})}return a},{initCallback:h,enterCallback:c,updateCallback:d,exitCallback:u}=this,p=e=>{e.onInit(((e,t)=>{q(e,t),h&&h(e,t.datum)})).onEnter(((e,t)=>{q(e,t),c&&c(e,t.datum)})).onUpdate(((e,t)=>{q(e,t),d&&d(e,t.datum)})).onExit(((e,t)=>{q(e,t),u&&u(e,t.datum)}))},f=t=>{for(;a<r;){i++;const r=a++,s=e[r],n=this.renderer.createSelection();if(this.boundData.push(s),this.selections.push(n),p(n),n.bind(l(s)),i%this.stepsBetweenChecks==0&&t()<=0)break}return a>=r};let g=0;const x=Math.min(r,this.boundData.length),v=t=>{for(;g<x;){i++;const r=g++,a=e[r],s=this.selections[r];if(this.boundData[r]=a,p(s),s.bind(l(a)),i%this.stepsBetweenChecks==0&&t()<=0)break}return g>=x},m=e=>{let t=r;for(;t<this.boundData.length;){i++;const r=this.selections[t];if(t++,p(r),r.bind([]),i%this.stepsBetweenChecks==0&&e()<=0)break}return this.boundData.splice(r,t-r),this.selections.splice(r,t-r),r>=this.boundData.length};return this.bindingTask={id:this,callback:e=>(i=0,m(e)&&v(e)&&f(e)),runUntilDone:!0},this.workScheduler.scheduleUniqueTask(this.bindingTask),this}clear(){let e=0;const t=t=>{let i=0;for(;i<this.boundData.length;){e++;const r=this.selections[i];if(i++,r.clear(),e%this.stepsBetweenChecks==0&&t()<=0)break}return this.boundData.splice(0,i),this.selections.splice(0,i),!this.boundData.length};return this.clearingTask={id:this.clearingTaskId,callback:i=>{e=0;const r=t(i);return r&&delete this.clearingTask,r},runUntilDone:!0},this.bindingTask&&(this.workScheduler.unscheduleTask(this.bindingTask),delete this.bindingTask),this.workScheduler.scheduleUniqueTask(this.clearingTask),this}hitTest(e){throw new Error("Not yet implemented")}}function Z(e){return!(!e||!(e instanceof Function||e.callback instanceof Function))}function X(e){if(!Z(e))throw new Error("Provided object was not a work task or function");return e instanceof Function?e:void 0!==e.id?e.id:e.callback}function Y(e){if(!Z(e))throw new Error("Provided object was not a work task or function");return e instanceof Function?{callback:e,id:e}:void 0!==e.id?e:Object.assign(Object.assign({},e),{id:e.callback})}class Q{constructor(){this.idSet=new Set,this.taskList=[]}get length(){return this.taskList.length}hasTaskId(e){return this.idSet.has(e)}hasTask(e){return this.hasTaskId(X(e))}getTaskById(e){if(!this.hasTaskId(e))return;const t=this.findTaskIndexById(e);if(-1===t)throw new D("Could not find matching task in task list");return this.taskList[t]}enqueueTask(e){if(this.hasTask(e))return;const t=Y(e);this.idSet.add(t.id),this.taskList.push(t)}dequeueTask(){const e=this.taskList.shift();if(!e)throw new Error("No tasks remain to dequeue");return this.idSet.delete(e.id),e}removeTaskById(e){if(!this.hasTaskId(e))return;const t=this.findTaskIndexById(e);if(-1===t)throw new D("Could not find matching task in task list");const[i]=this.taskList.splice(t,1);return this.idSet.delete(i.id),i}removeTask(e){return this.removeTaskById(X(e))}findTaskIndexById(e){let t=-1;for(let i=0;i<this.taskList.length;i++)if(this.taskList[i].id===e){if(-1!==t)throw new D("Duplicate task found in task list");t=i}return t}}const J=Object.freeze({timingFunctions:b,maxWorkTimeMs:20});class K{constructor(e=J){this.isEnabled=!1,this.isPerformingWork=!1,this.presentWorkQueue=new Q,this.futureWorkQueue=new Q;const t=Object.assign({},J,e||{});this.timingFunctions=Object.freeze(Object.assign({},b,t&&t.timingFunctions||{})),this.maxWorkTimeMs=t.maxWorkTimeMs,this.enable()}scheduleTask(e){const t=Y(e);return this.presentWorkQueue.hasTask(t)||this.futureWorkQueue.hasTask(t)||(this.isPerformingWork&&!t.beginImmediately?this.futureWorkQueue.enqueueTask(t):this.presentWorkQueue.enqueueTask(t)),this.updateTimer(),t}getTask(e){const t=X(e),i=this.presentWorkQueue.getTaskById(t),r=this.futureWorkQueue.getTaskById(t);if(i&&r)throw new D("Found two matching tasks when at most one is allowed");return i||r||void 0}unscheduleTask(e){const t=X(e),i=this.presentWorkQueue.removeTaskById(t),r=this.futureWorkQueue.removeTaskById(t);if(i&&r)throw new D("Found two matching tasks when at most one is allowed");return this.updateTimer(),i||r||void 0}isScheduledTask(e){return this.isScheduledId(X(e))}isScheduledId(e){return this.presentWorkQueue.hasTaskId(e)||this.futureWorkQueue.hasTaskId(e)}scheduleUniqueTask(e){const t=Y(e);return this.unscheduleTask(t),this.scheduleTask(t),t}enable(){return this.isEnabled=!0,this.updateTimer(),this}disable(){return this.isEnabled=!1,this.updateTimer(),this}updateTimer(){if(this.isEnabled&&this.presentWorkQueue.length){if(void 0===this.animationFrameTimer){const{requestAnimationFrame:e}=this.timingFunctions;this.animationFrameTimer=e((()=>{this.animationFrameTimer=void 0,this.performWork()}))}}else if(void 0!==this.animationFrameTimer){const{cancelAnimationFrame:e}=this.timingFunctions;e(this.animationFrameTimer),this.animationFrameTimer=void 0}}performWork(){if(this.isPerformingWork)throw new D("Only one invocation of performWork is allowed at a time");this.isPerformingWork=!0;const{now:e}=this.timingFunctions;let t=0;const i=e(),r=()=>this.maxWorkTimeMs+i-e();try{for(;this.presentWorkQueue.length&&!(t>0&&r()<=0);){const e=this.presentWorkQueue.dequeueTask();t++;const i=e.callback.call(null,r);if(!e.runUntilDone||i)continue;let a=i;for(;!a&&r()>0;)a=e.callback.call(null,r);if(!a){this.futureWorkQueue.enqueueTask(e);break}}}finally{for(this.isPerformingWork=!1;this.futureWorkQueue.length;){const e=this.futureWorkQueue.dequeueTask();this.scheduleTask(e)}this.updateTimer()}}}class ee{constructor(e={}){this.scale=new l((()=>{this.handleViewChange()})),this.offset=new l((()=>{this.handleViewChange()})),this.sprites=[],this.waitingSprites=[],this.instanceCount=0,this.callbacksIndexRange=new F,this.needsTextureSyncIndexRange=new F,this.needsRebaseIndexRange=new F,this.toBeRemovedIndexRange=new F,this.toBeRemovedTsRange=new F,this.removedIndexRange=new F,this.toDrawTsRange=new F,this.drawTaskId=Symbol("drawTask"),this.textureSyncTaskId=Symbol("textureSyncTask"),this.rebaseCount=0,this.hitTestCount=0,this.runRemovalTaskId=Symbol("runRemovalTaskId"),this.runAssignWaitingTaskId=Symbol("runAssignWaitingTask"),this.rebaseTaskId=Symbol("rebaseTask"),this.runCallbacksTaskId=Symbol("runCallbacksTask"),this.isViewInitialized=!1,this.stepsBetweenRemainingTimeChecks=500;const t=Object.assign({},N,e),{timingFunctions:i}=t,{now:a}=i;if(this.basisTs=a(),this.elapsedTimeMs=()=>a()-this.basisTs,this.workScheduler=new K({timingFunctions:i}),"function"==typeof t.devicePixelRatio){const e=t.devicePixelRatio;this.getDevicePixelRatio=()=>{const t=e();if(isNaN(t)||t<=0)throw new RangeError("Callback returned invalid devicePixelRatio");return t}}else if("number"==typeof t.devicePixelRatio){const{devicePixelRatio:e}=t;if(isNaN(e)||e<=0)throw new RangeError("Provided devicePixelRatio value is invalid");this.getDevicePixelRatio=()=>e}this.antialiasingFactor=t.antialiasingFactor,this.container=t.container,this.defaultTransitionTimeMs=t.defaultTransitionTimeMs,this.orderZGranularity=t.orderZGranularity;const s=window.createREGL||r.default;if(!s)throw new Error("Could not find REGL");this.canvas=document.createElement("canvas"),Object.assign(this.canvas.style,{border:0,height:"100%",left:0,margin:0,padding:0,top:0,width:"100%"}),this.container.appendChild(this.canvas);const{width:n,height:c}=this.canvas.getBoundingClientRect(),b=this.getDevicePixelRatio();this.canvas.height=c*b,this.canvas.width=n*b;const T=this.regl=s({attributes:{preserveDrawingBuffer:!0},canvas:this.canvas,extensions:["angle_instanced_arrays","OES_texture_float","OES_texture_float_linear"]});this.initView();const y=this.attributeMapper=new o({maxTextureSize:T.limits.maxTextureSize,desiredSwatchCapacity:t.desiredSpriteCapacity,dataChannelCount:4});this.previousValuesFramebuffer=T.framebuffer({color:T.texture({width:y.textureWidth,height:y.textureHeight,channels:y.dataChannelCount,type:"float32",mag:"nearest",min:"nearest"}),depthStencil:!1}),this.previousValuesTexture=T.texture({width:y.textureWidth,height:y.textureHeight,channels:y.dataChannelCount,type:"float32",mag:"nearest",min:"nearest"}),this.targetValuesArray=new Float32Array(y.totalValues),this.targetValuesTexture=T.texture({width:y.textureWidth,height:y.textureHeight,channels:y.dataChannelCount,data:this.targetValuesArray,type:"float32",mag:"nearest",min:"nearest"}),this.instanceSwatchUvValues=y.generateInstanceSwatchUvValues(),this.instanceIndexValues=new Float32Array(y.totalSwatches);for(let e=0;e<y.totalSwatches;e++)this.instanceIndexValues[e]=e;const S=this.hitTestAttributeMapper=new o({maxTextureSize:T.limits.maxTextureSize,desiredSwatchCapacity:y.totalSwatches,dataChannelCount:4,attributes:[{attributeName:"Hit"}]});this.instanceHitTestOutputUvValues=this.hitTestAttributeMapper.generateInstanceSwatchUvValues(),this.instanceHitTestInputUvValues=new Float32Array(this.instanceSwatchUvValues.length),this.instanceHitTestInputIndexActiveValues=new Float32Array(2*y.totalSwatches),this.hitTestOutputValuesFramebuffer=T.framebuffer({color:T.texture({width:S.textureWidth,height:S.textureHeight,channels:S.dataChannelCount,type:"uint8",mag:"nearest",min:"nearest"}),depthStencil:!1}),this.hitTestOutputValues=new Uint8Array(S.dataChannelCount*S.totalSwatches),this.hitTestOutputResults=new Float32Array(S.totalSwatches),this.glyphMapper=new z(t.glyphMapper);for(const e of t.glyphs.split(""))this.glyphMapper.addGlyph(e);this.sdfTexture=T.texture({height:this.glyphMapper.textureSize,width:this.glyphMapper.textureSize,min:"linear",mag:"linear",wrap:"clamp",data:this.glyphMapper.textureData,format:"luminance",type:"float32"}),this.instanceSwatchUvBuffer=this.regl.buffer(this.instanceSwatchUvValues),this.instanceIndexBuffer=this.regl.buffer(this.instanceIndexValues),this.instanceHitTestInputUvBuffer=this.regl.buffer(this.instanceHitTestInputUvValues),this.instanceHitTestInputIndexActiveBuffer=this.regl.buffer(this.instanceHitTestInputIndexActiveValues),this.instanceHitTestOutputUvBuffer=this.regl.buffer(this.instanceHitTestOutputUvValues),this.instanceRebaseUvValues=new Float32Array(this.instanceSwatchUvValues.length),this.instanceRebaseUvBuffer=this.regl.buffer({usage:"dynamic",type:"float",data:this.instanceRebaseUvValues}),this.drawCommand=function(e){const t={blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:1,dstRGB:"one minus src alpha",dstAlpha:1},equation:{rgb:"add",alpha:"add"},color:[0,0,0,0]},viewport:()=>({x:0,y:0,width:e.canvas.width,height:e.canvas.height}),frag:h`
precision lowp float;

/**
 * Each sprite receives the same vertex coordinates, which describe a unit
 * square centered at the origin. However, the distance calculations performed
 * by the fragment shader use a distance of 1 to mean the dead center of a
 * circle, which implies a diameter of 2. So to convert from sprite vertex
 * coordinate space to edge distance space requires a dilation of 2.
 */
const float EDGE_DISTANCE_DILATION = 2.;

/**
 * View matrix for converting from world space to clip space.
 */
uniform mat3 viewMatrix;

/**
 * Signed-distance field (SDF) texture. Sampled for implementing glyphs of text.
 */
uniform sampler2D sdfTexture;

/**
 * Antialiasing factor defines the window radius in device pixels to use to
 * determine the contribution of border and fill colors for antialiasing.
 */
uniform float antialiasingFactor;

/**
 * Varying time value, eased using cubic-in-out between the previous and target
 * timestamps for this Sprite.
 */
varying float varyingT;

/**
 * Interpolated, per-vertex coordinate attributes for the quad into which the
 * sprite will be rendered.
 */
varying vec2 varyingVertexCoordinates;

/**
 * Threshold distance values to consider the pixel outside the shape (X) or
 * inside the shape (Y). Values between constitute the border.
 */
varying vec2 varyingBorderThresholds;

/**
 * Scale value for converting edge distances to pixel distances in the fragment
 * shader.
 */
varying float varyingEdgeToPixelScale;

/**
 * Aspect ratio of the sprite's renderable area (XY) and their inverses (ZW).
 * One component of each pair will be 1. For the XY pair, the other component
 * be be greater than 1. and for the inverse pair it will be smaller.
 *
 * For example, a rectangle that's twice as wide as it is tall wolud have
 * varyingAspectRatio equal to vec4(2., 1., .5, 1.).
 */
varying vec4 varyingAspectRatio;

/**
 * Color attributes.
 */
varying vec4 varyingBorderColor;
varying vec4 varyingFillColor;

/**
 * Shape attributes used by fragment shader.
 */
varying float varyingPreviousSides;
varying float varyingTargetSides;
varying vec4 varyingPreviousShapeTexture;
varying vec4 varyingTargetShapeTexture;

const float PI = 3.1415926535897932384626433832795;

/**
 * Given a line segment described by two points (a,b), find the point along that
 * line segment nearest to a point of interest (p).
 */
vec2 closestPoint(vec2 a, vec2 b, vec2 p) {
  vec2 pa = p - a;
  vec2 ba = b - a;
  vec2 baNorm = normalize(ba);
  float baLen = length(ba);
  float projectedLen = dot(baNorm, pa);
  vec2 closest =
    projectedLen < 0. ? a :
    projectedLen > baLen ? b :
    a + baNorm * projectedLen;
  return closest;
}

/**
 * Matrix to flip XY coordinates for theta computation. To orient polygons and
 * stars pointing upwards, we compute angles counter-clockwise from vertical.
 */
const mat2 FLIP_MATRIX = mat2(vec2(0., 1.), vec2(-1., 0.));

/**
 * Given a point in the range (-1,-1) to (1,1), compute the angle to that point,
 * going counter-clockwise from vertical.
 */
float computeTheta(vec2 point) {
  vec2 f = FLIP_MATRIX * point;
  return atan(f.y, f.x) + PI;
}

/**
 * Given the varying coordinates of interest, the dimensions of the shape's
 * bounding box, the number of sides, and a list of repeating offset radii,
 * determine the signed distance from the coordinates to the nearest edge of the
 * shape.
 *
 * @param sides Number of sides of the polygon or star.
 * @param radii List of four repeating offset radii to render stars. If all
 * values are 0., then the rendered distance will be a regular polygon.
 */
float getDistStar(int sides, vec4 radii) {
  float fSides = float(sides);

  // Flip radii (0. means align with unit circle, 1. means center of shape).
  radii = 1. - radii;

  // Angle to cut through the midpoint of a regular polygon's side.
  float piSides = PI / fSides;

  // With the polygon pointed up, this is the angle (counter-clockwise from top)
  // to the point just before crossing the X-axis. For a triangle, this will
  // just be the same as piSides.
  float wideAngle = floor(fSides * .5) * piSides;

  // Compute radius for dilation to fill bounding box.
  float dilation = 1. / max(sin(wideAngle), sin(piSides));

  // Compute the height of the shape, for centering.
  float height = dilation * (1. + max(cos(PI - 2. * wideAngle), cos(piSides)));

  // The point of interest starts with the varyingVertexCoordinates, but shifted
  // to center the shape vertically.
  vec2 poi = EDGE_DISTANCE_DILATION * varyingVertexCoordinates +
    vec2(0., EDGE_DISTANCE_DILATION - height);

  // Compute theta for point of interest, counter-clockwise from vertical.
  float theta = computeTheta(poi);

  // Incorporate aspect ratio calculation. This ensures that distances to
  // borders do not stretch with the shape.
  vec2 aspect = varyingAspectRatio.xy;
  poi *= aspect;

  // Compute which side of the star we're on, and use this to compute adjustment
  // to a and b points. This creates the star effect.
  float side = floor(theta / PI * .5 * fSides);

  float minDistance = 1.e20;
  float distanceSign;

  // Look at sides to the left/right (clockwise) to find the closest.
  for (int i = -1; i < 2; i++) {
    float thisSide = side + float(i);
    float m = mod(thisSide + 4., 4.);

    vec2 adjust =
      m < 1. ? radii.xy :
      m < 2. ? radii.yz :
      m < 3. ? radii.zw :
      radii.wx;

    // Find the ab line segment endpoints.
    float thetaA = 2. * thisSide * piSides;
    float thetaB = thetaA + 2. * piSides;
    vec2 a = aspect * dilation * adjust.x * vec2(-sin(thetaA), cos(thetaA));
    vec2 b = aspect * dilation * adjust.y * vec2(-sin(thetaB), cos(thetaB));

    // Find the closest point on the segment and update minDistance.
    vec2 c = closestPoint(a, b, poi).xy;
    minDistance = min(minDistance, distance(poi, c));

    // If we're in our own segment, capture the distance sign.
    if (i == 0) {
      // Use cross product to determine if we're inside or outside the line.
      distanceSign = sign(cross(vec3(b - a, 0.), vec3(poi - c, 0.)).z);
    }
  }

  return minDistance * distanceSign;
}

/**
 * Convenience method for calling getDistStar() with a fixed size array of 0.
 * values to create a regular polygon.
 */
float getDistPolygon(int sides) {
  return getDistStar(sides, vec4(0.));
}

/**
 * Estimate the distance from the varying vertex coordinate to the nearest point
 * on an ellipse of the specified aspect ratio. Mathematically, a closed-form
 * solution for this problem has not yet been discovered.
 *
 * Higher accuracy estimates of ellipse distance are possible with more
 * computation steps, but the procedure used here yields sufficient accurancy
 * for data visualization purposes.
 */
float getDistEllipse() {
  // All quadrants can be treated the same, so use the absolute value of the
  // vertex coordinates, and flip if needed so that the X dimension is always
  // the greater.
  bool flipped = varyingAspectRatio.x < varyingAspectRatio.y;
  vec4 aspectRatio = flipped ? varyingAspectRatio.yxwz : varyingAspectRatio;

  // Point of interest in the expanded circle (before aspect ratio stretching).
  vec2 circlePoint = EDGE_DISTANCE_DILATION * abs(
      flipped ? varyingVertexCoordinates.yx : varyingVertexCoordinates);

  // Capture length for inside/outside checking.
  float len = length(circlePoint);

  // Point of interest in the ellipse (after aspect ratio stretching).
  vec2 ellipsePoint = circlePoint * aspectRatio.xy;

  // Compute the angle from the x-axis up to the point of interest.
  float theta = PI - atan(circlePoint.y, -circlePoint.x);

  // Find the point where a ray from the origin through c hits the ellipse.
  vec2 p1 = aspectRatio.xy * vec2(cos(theta), sin(theta));

  // Find a second point by casting up from the x-axis. If the point of interest
  // is outside the ellipse and past the tip, use the tip coordinate.
  float invAr2 = aspectRatio.z * aspectRatio.z;
  vec2 p2 = ellipsePoint.x > aspectRatio.x ? vec2(aspectRatio.x, 0.) :
    vec2(ellipsePoint.x, sqrt(1. - ellipsePoint.x * ellipsePoint.x * invAr2));

  // Take the minimum distance between ray intersection point and vertical.
  float dist = min(distance(ellipsePoint, p1), distance(ellipsePoint, p2));

  // If the point of interest is outside of the ellipse, smooth by checking the
  // distance to one more point: the point on the ellipse between p1 and p2 such
  // that its X coordinate is half way between.
  if (len > 1.) {
    vec2 pm = mix(p1, p2, .5);
    pm.y = sqrt(1. - pm.x * pm.x * invAr2);
    dist = min(dist, distance(ellipsePoint, pm));
  }

  // Return signed distance.
  return dist * sign(1. - len);
}

/**
 * Compute the signed distance from the point of interest to the nearest edge of
 * the sprite bonding box.
 */
float getDistRect() {
  // All quadrants can be treated the same, so we limit our computation to the
  // top right.
  vec2 ar = varyingAspectRatio.xy;
  vec2 p = ar * EDGE_DISTANCE_DILATION * abs(varyingVertexCoordinates);

  // If the point of intrest is beyond the top corner, return the negative
  // distance to that corner.
  bvec2 gt = greaterThan(p, ar);
  if (all(gt)) {
    return -distance(p, ar);
  }
  if (gt.x) {
    return ar.x - p.x;
  }
  if (gt.y) {
    return ar.y - p.y;
  }

  // Determine distance to nearest edge.
  vec2 d = ar - p;
  vec2 dabs = abs(d);
  return dabs.x < dabs.y ? d.x : d.y;
}

/**
 * Sample the distance from the sdfTexture. The texture is assumed to have
 * one-dimensional distances in the X and Y componets and two-dimensional
 * distance in the Z component.
 *
 * @param shapeTexture UV coordinates and width/height of the region of the SDF
 * texture within which to sample (corresponds to the glyph being rendered).
 */
float getDistSDF(vec4 shapeTexture) {
  // Clamp vertex coordinates to the -1 to 1 range.
  vec2 clamped = clamp(varyingVertexCoordinates, -1., 1.);

  // For sampling, UV coordinates are Y-flipped and shifted.
  vec2 coordUv = clamped * vec2(1., -1.) + .5;

  // Focus on the middle 50% of the UV space. Assumes glyphs were rendered with
  // buffer roughly equal to the font size.
  //
  //   +------+       .      .
  //   |      |         +--+
  //   |  k   |  =>     |k |
  //   |      |         +--+
  //   +------+       .      .
  //
  coordUv *= .5;
  coordUv += .25;

  // Offset into the texture according to the shapeTexture's location and size.
  vec2 textureUv =
      shapeTexture.xy +
      shapeTexture.zw * coordUv;

  return texture2D(sdfTexture, textureUv).z;
}

/**
 * Generic distance function that calls through to one of the more specific
 * distance functions.
 *
 * @param sides Number of sides of the polygon/star, or special value:
 *  s < 0      : Reserved / Undefined.
 *  s == 0     : Use SDF texture coordinates.
 *  s == 1     : Circle.
 *  s == 2     : Filled rectangle.
 *  s > 2      : Polygon / Star.
 * @param textureUv Offset into SDF texture.
 */
float getDist(int sides, vec4 shapeTexture) {
  return
    sides == 0 ? getDistSDF(shapeTexture) :
    sides == 1 ? getDistEllipse() :
    sides == 2 ? getDistRect() :
    sides > 2 ? getDistPolygon(sides) :
    1.; // Reserved / undefined.
}

void main () {
  int previousSides = int(varyingPreviousSides);
  int targetSides = int(varyingTargetSides);

  float previousDistance = getDist(previousSides, varyingPreviousShapeTexture);
  float targetDistance = getDist(targetSides, varyingTargetShapeTexture);
  float signedDistance = mix(previousDistance, targetDistance, varyingT);

  // Create an antialiasing window around the determined signed distance with
  // radius equal to 1 device pixel (diameter of 2 device pixels).
  vec2 window = signedDistance +
    varyingEdgeToPixelScale * antialiasingFactor * vec2(-1., 1.);

  // Width of the antialiasing window.
  float width = window.y - window.x;

  // Determine the contribution to the window of the border and fill.
  vec2 contrib;

  if (width > 0.) {
    // Amount of space within the window that overlaps the border.
    contrib.x =
      min(varyingBorderThresholds.y, window.y) -
      max(varyingBorderThresholds.x, window.x);

    // Amount of space within the window that overlaps the fill color. May be
    // negative, if no part of the window overlaps.
    contrib.y = width - (varyingBorderThresholds.y - window.x);

    // Normalize contributions to the antialiasing window's width.
    contrib /= width;
  } else {
    // If zero antialiasing, do a hard cutoff.
    contrib.x = float(
      varyingBorderThresholds.x <= signedDistance &&
      signedDistance < varyingBorderThresholds.y
    );
    contrib.y = float(varyingBorderThresholds.y <= signedDistance);
  }

  // Clamp contribution values to possible range.
  contrib = clamp(contrib, 0., 1.);

  // Mix alpha channels according to their absolute contributions.
  float alpha =
    contrib.x * varyingBorderColor.a +
    contrib.y * varyingFillColor.a;

  // Discard low-alpha pixels so that sprites that are out of their natural
  // order (due to OrderZ) are visible underneath higher sprites.
  if (alpha < .01) {
    discard;
    return;
  }

  // Mix RGB channels of border and fill according to their relative
  // contributions to the total.
  vec2 rel = contrib / (contrib.x + contrib.y);
  vec3 color = rel.x * varyingBorderColor.rgb + rel.y * varyingFillColor.rgb;

  gl_FragColor = vec4(color, alpha);
}
`,vert:m(e.attributeMapper),attributes:{vertexCoordinates:[[-.5,-.5],[.5,-.5],[-.5,.5],[.5,.5]],instanceSwatchUv:{buffer:e.instanceSwatchUvBuffer,divisor:1},instanceIndex:{buffer:e.instanceIndexBuffer,divisor:1}},uniforms:{ts:()=>e.elapsedTimeMs(),antialiasingFactor:()=>e.antialiasingFactor,devicePixelRatio:()=>e.getDevicePixelRatio(),instanceCount:()=>e.instanceCount,orderZGranularity:()=>e.orderZGranularity,viewMatrix:()=>e.getViewMatrix(),viewMatrixScale:()=>e.getViewMatrixScale(),projectionMatrix:t=>e.getProjectionMatrix(t),sdfTexture:e.sdfTexture,previousValuesTexture:e.previousValuesFramebuffer,targetValuesTexture:e.targetValuesTexture},primitive:"triangle strip",count:4,instances:()=>e.instanceCount},i=e.regl(t);return()=>{e.regl.clear({color:[0,0,0,0],depth:1,framebuffer:null,stencil:0}),i.apply(null)}}(this),this.rebaseCommand=function(e){const t={frag:(i=e.attributeMapper,h`
precision lowp float;

uniform float ts;

uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

varying float varyingTexelIndex;
varying vec2 varyingRebaseUv;

vec4 previousTexelValues[${i.texelsPerSwatch}];
vec4 targetTexelValues[${i.texelsPerSwatch}];

${i.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${i.generateAttributeDefinesGLSL("target","targetTexelValues")}

// Import utility shader functions.
${d()}
${u()}

float computeValueAtTime(
    float startingValue,
    float startingDelta,
    float targetValue,
    float ts) {
  float rangeT =
    ts >= targetTransitionTimeMs() ? 1. :
    ts <= previousTransitionTimeMs() ? 0. :
    clamp(
        range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
        0., 1.);
  float easeT = cubicEaseInOut(rangeT);

  float currentValue = mix(startingValue, targetValue, easeT);
  float projectedValue = startingDelta *
    (targetTransitionTimeMs() - previousTransitionTimeMs());

  return currentValue + projectedValue * rangeT * pow(1. - rangeT, 3.);
}

// DELTA_MS is the duration in milliseconds to use when estimating the
// 'instantaneous' change in a value. INV_DELTA_MS is its inverse.
#define DELTA_MS 1.
#define INV_DELTA_MS 1.

float computeDeltaAtTime(
    float startingValue,
    float startingDelta,
    float targetValue,
    float ts
) {
  if (ts >= targetTransitionTimeMs()) {
    return 0.;
  }
  if (ts <= previousTransitionTimeMs()) {
    return startingDelta;
  }
  return (
      computeValueAtTime(
          startingValue, startingDelta, targetValue, ts + DELTA_MS) -
      computeValueAtTime(
          startingValue, startingDelta, targetValue, ts)
      ) * INV_DELTA_MS;
}

float computeThresholdValue(
    float previousValue,
    float targetValue,
    float rebaseTs
) {
  float mid = mix(previousTransitionTimeMs(), targetTransitionTimeMs(), .5);
  return rebaseTs < mid ? previousValue : targetValue;
}

void readInputTexels() {
${i.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","varyingRebaseUv")}
${i.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","varyingRebaseUv")}
}

void setOutputTexel() {
  float rebaseTs = ts;
  ${i.generateRebaseFragmentGLSL("previousTexelValues","targetTexelValues","varyingTexelIndex","rebaseTs")}
}

void main () {
  readInputTexels();
  setOutputTexel();
}
`),vert:w(e.attributeMapper),attributes:{vertexCoordinates:[[-.5,-.5],[.5,-.5],[-.5,.5],[.5,.5]],instanceRebaseUv:{buffer:()=>e.instanceRebaseUvBuffer,divisor:1}},uniforms:{ts:()=>e.elapsedTimeMs(),targetValuesTexture:e.targetValuesTexture,previousValuesTexture:e.previousValuesTexture},primitive:"triangle strip",count:4,instances:()=>e.rebaseCount,framebuffer:()=>e.previousValuesFramebuffer};var i;const r=e.regl(t);return()=>{r()}}(this),this.hitTestCommand=function(e){const t={frag:h`
precision lowp float;

// Need to know the maximum possible value for the index of the Sprite to
// normalize the value for RGBA packing.
uniform float capacity;

varying float varyingHitTestResult;

vec4 packFloatToVec4i(const float value) {
  const vec4 bitSh = vec4(256. * 256. * 256., 256. * 256., 256., 1.);
  const vec4 bitMsk = vec4(0., 1./256., 1./256., 1./256.);
  vec4 res = fract(value * bitSh);
  res -= res.xxyz * bitMsk;
  return res;
}

float fitToRange(const float result) {
  // Adding 1 to account for missing values (-1 becomes 0, etc.)
  return (result + 1.) / (capacity + 1.);
}

void main () {
  // Packing requires a number in the range 0-1.
  float n = fitToRange(varyingHitTestResult);
  gl_FragColor = packFloatToVec4i(n);
}
`,vert:(i=e.hitTestAttributeMapper,r=e.attributeMapper,h`
precision lowp float;

/**
 * WebGL vertex shaders output coordinates in clip space, which is a 3D volume
 * where each component is clipped to the range (-1,1). The distance from
 * edge-to-edge is therefore 2.
 */
const float CLIP_SPACE_RANGE = 2.;

/**
 * Each sprite receives the same vertex coordinates, which describe a unit
 * square centered at the origin. However, the distance calculations performed
 * by the fragment shader use a distance of 1 to mean the dead center of a
 * circle, which implies a diameter of 2. So to convert from sprite vertex
 * coordinate space to edge distance space requires a dilation of 2.
 */
const float EDGE_DISTANCE_DILATION = 2.;

uniform float ts;

uniform float devicePixelRatio;

/**
 * Screen pixel coordinates for performing the hit test. The XY channels contain
 * the screen x and y coordinates respectively. The ZW channels hold the width
 * and height of the bounding box of interest. Currently those are ignored.
 */
uniform vec4 hitTestCoordinates;
uniform bool inclusive;

uniform mat3 viewMatrix;

/**
 * Scale includes the X and Y dimensions of the viewMatrix, and their inverses
 * in the WZ components.
 */
uniform vec4 viewMatrixScale;

uniform sampler2D previousValuesTexture;
uniform sampler2D targetValuesTexture;

attribute vec2 vertexCoordinates;

attribute vec2 inputUv;
attribute vec2 indexActive;
attribute vec2 outputUv;

#define TEXELS_PER_SWATCH ${i.texelsPerSwatch}.
#define TEXTURE_WIDTH ${i.textureWidth}.
#define TEXTURE_HEIGHT ${i.textureHeight}.

// The result of the hit test, written to the data texel by the fragment shader.
varying float varyingHitTestResult;

vec4 previousTexelValues[${r.texelsPerSwatch}];
vec4 targetTexelValues[${r.texelsPerSwatch}];

${r.generateAttributeDefinesGLSL("previous","previousTexelValues")}
${r.generateAttributeDefinesGLSL("target","targetTexelValues")}

float rangeT;
float easeT;

// Import utility shader functions.
${d()}
${u()}
${p("rangeT","easeT")}
${v()}
${x()}
${g()}
${f()}

void readInputTexels() {
${r.generateTexelReaderGLSL("previousTexelValues","previousValuesTexture","inputUv")}
${r.generateTexelReaderGLSL("targetTexelValues","targetValuesTexture","inputUv")}
}

const vec2 swatchSize =
  vec2(TEXELS_PER_SWATCH / TEXTURE_WIDTH, 1. / TEXTURE_HEIGHT);

bool spriteOverlapsTest(const vec4 spriteBox, const vec4 testBox) {
  return (
    spriteBox.x <= testBox.x + testBox.z &&
    spriteBox.x + spriteBox.z >= testBox.x &&
    spriteBox.y >= testBox.y - testBox.w &&
    spriteBox.y + spriteBox.w <= testBox.y
  );
}

bool spriteInsideTest(const vec4 spriteBox, const vec4 testBox) {
  return (
    spriteBox.x >= testBox.x &&
    spriteBox.x + spriteBox.z <= testBox.x + testBox.z &&
    spriteBox.y <= testBox.y &&
    spriteBox.y + spriteBox.w >= testBox.y - testBox.w
  );
}

void main () {
  readInputTexels();

  // Compute time variables.
  rangeT =
    ts >= targetTransitionTimeMs() ? 1. :
    ts <= previousTransitionTimeMs() ? 0. :
    clamp(range(previousTransitionTimeMs(), targetTransitionTimeMs(), ts),
        0., 1.);
  easeT = cubicEaseInOut(rangeT);

  // Compute current size component values by interpolation (parallelized).
  vec4 currentSizePixelAndWorld = computeCurrentSizePixelAndWorld();
  vec2 currentSizePixel = currentSizePixelAndWorld.xy;
  vec2 currentSizeWorld = currentSizePixelAndWorld.zw;

  vec2 currentGeometricZoom = computeCurrentValue(
      previousGeometricZoom(),
      previousGeometricZoomDelta(),
      targetGeometricZoom()
  );

  vec4 currentMaxAndMinSizePixel = computeCurrentMaxAndMinSizePixel();
  vec2 currentMaxSizePixel = currentMaxAndMinSizePixel.xy;
  vec2 currentMinSizePixel = currentMaxAndMinSizePixel.zw;

  // Compute the current size of the sprite in world units, including the effect
  // of geometric zoom and applying min and max pixel sizes.
  vec2 computedSize = computeSize(
    currentSizeWorld,
    currentSizePixel,
    currentGeometricZoom,
    viewMatrixScale,
    currentMaxSizePixel,
    currentMinSizePixel
  );

  // Compute border attributes in parallel.
  vec3 borderProperties = computeCurrentValue(
      vec3(
        previousBorderRadiusPixel(),
        previousBorderRadiusRelative(),
        previousBorderPlacement()),
      vec3(
        previousBorderRadiusPixelDelta(),
        previousBorderRadiusRelativeDelta(),
        previousBorderPlacementDelta()),
      vec3(
        targetBorderRadiusPixel(),
        targetBorderRadiusRelative(),
        targetBorderPlacement())
  );
  float currentBorderRadiusPixel = borderProperties.x;
  float currentBorderRadiusRelative = borderProperties.y;
  float currentBorderPlacement = borderProperties.z;

  // Project the computed size into pixels by using the viewMatrixScale. Note
  // that this already includes the effect of the devicePixelRatio, and a 2x
  // multiplier for clip-space, which goes from -1 to 1 in all dimensions.
  vec2 projectedSizePixel = computedSize.xy * viewMatrixScale.xy;

  // Compute the distance from the sprite edge to the extent of the border. Used
  // to shift the corners before hit testing to make sure the bounding box
  // includes borders outside of the shape.
  float edgeDistance = currentBorderRadiusRelative + (
      currentBorderRadiusPixel *
      CLIP_SPACE_RANGE *
      EDGE_DISTANCE_DILATION *
      devicePixelRatio /
      min(projectedSizePixel.x, projectedSizePixel.y)
    );

  // Shift coorner vertices outward to account for borders, which may expand
  // the bounding box of the sprite. XY are the bottom left corner, ZW are for
  // the top right.
  vec4 cornerCoordinates = vec4(-.5, -.5, .5, .5) *
    (1. + edgeDistance * currentBorderPlacement);

  // Compute the current position component attributes.
  vec2 currentPositionPixel = computeCurrentValue(
      previousPositionPixel(),
      previousPositionPixelDelta(),
      targetPositionPixel());

  vec2 currentPositionWorld = computeCurrentValue(
      previousPositionWorld(),
      previousPositionWorldDelta(),
      targetPositionWorld());

  vec2 currentPositionRelative = computeCurrentValue(
      previousPositionRelative(),
      previousPositionRelativeDelta(),
      targetPositionRelative());

  // Project the world position into pixel space for the bottom left and top
  // right corners of the sprite's quad.
  vec2 bottomLeft = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      cornerCoordinates.xy,
      viewMatrix
  ) * .5 / devicePixelRatio;
  vec2 topRight = computeViewVertexPosition(
      currentPositionWorld,
      computedSize,
      currentPositionRelative,
      currentPositionPixel,
      cornerCoordinates.zw,
      viewMatrix
  ) * .5 / devicePixelRatio;
  vec4 spriteBox = vec4(bottomLeft.xy, topRight.xy - bottomLeft.xy);

  // Hit test coordinates are presented based on the top-left corner, so to
  // orient it from the bottom left we need to subtract the height.
  vec4 testBox = hitTestCoordinates + vec4(0., hitTestCoordinates.w, 0., 0.);

  // Test whether the coordinates of interest are within the sprite quad's
  // bounding box.
  bool hit = inclusive ?
    spriteOverlapsTest(spriteBox, testBox) :
    spriteInsideTest(spriteBox, testBox);

  // The hit test result will either be -1 if it's a miss (or the Sprite was
  // inactive), or it will be the index of the Sprite.
  varyingHitTestResult =
    indexActive.y <= 0. ? -1. :
    !hit ? -1. :
    indexActive.x;

  vec2 swatchUv =
    outputUv + (vertexCoordinates.xy + .5) * swatchSize;

  // Position the verts to write into the appropriate data texel.
  gl_Position = vec4(2. * swatchUv - 1., 0., 1.);
}
`),attributes:{vertexCoordinates:[[-.5,-.5],[.5,-.5],[-.5,.5],[.5,.5]],inputUv:{buffer:()=>e.instanceHitTestInputUvBuffer,divisor:1},indexActive:{buffer:()=>e.instanceHitTestInputIndexActiveBuffer,divisor:1},outputUv:{buffer:e.instanceHitTestOutputUvBuffer,divisor:1}},uniforms:{ts:()=>e.elapsedTimeMs(),capacity:()=>e.hitTestAttributeMapper.totalSwatches,devicePixelRatio:()=>e.getDevicePixelRatio(),hitTestCoordinates:()=>[e.hitTestParameters.x,e.hitTestParameters.y,e.hitTestParameters.width||0,e.hitTestParameters.height||0],inclusive:()=>void 0===e.hitTestParameters||!!e.hitTestParameters.inclusive,viewMatrix:()=>e.getViewMatrix(),viewMatrixScale:()=>e.getViewMatrixScale(),targetValuesTexture:e.targetValuesTexture,previousValuesTexture:e.previousValuesTexture},primitive:"triangle strip",count:4,instances:()=>e.hitTestCount,framebuffer:()=>e.hitTestOutputValuesFramebuffer};var i,r;const a=e.regl(t);return()=>{a()}}(this),this.queueDraw()}getDevicePixelRatio(){return"undefined"!=typeof window&&window.devicePixelRatio||1}initView(){if(this.isViewInitialized)return;const{width:e,height:t}=this.canvas.getBoundingClientRect();if(!e||!t)return console.warn("Delaying Scene initialization: canvas has zero size"),void(this.canvas.isConnected||console.debug("Canvas is not connected to the DOM"));this.lastDevicePixelRatio=this.getDevicePixelRatio(),this.canvas.width=e*this.lastDevicePixelRatio,this.canvas.height=t*this.lastDevicePixelRatio;const i=Math.min(e,t)||Math.max(e,t)||Math.min(window.innerWidth,window.innerHeight);this.scale.x=i,this.scale.y=i,this.offset.x=e/2,this.offset.y=t/2,this.isViewInitialized=!0}handleViewChange(){this.queueDraw()}resize(e){if(!this.isViewInitialized)return void this.initView();if(!this.lastDevicePixelRatio)throw new D("initView must set lastDevicePixelRatio");const t=this.canvas.width/this.lastDevicePixelRatio,i=this.canvas.height/this.lastDevicePixelRatio;e=e||{x:t/2,y:i/2};const r=t>0?e.x/t:.5,a=i>0?e.y/i:.5,{width:s,height:n}=this.canvas.getBoundingClientRect();this.lastDevicePixelRatio=this.getDevicePixelRatio(),this.canvas.width=s*this.lastDevicePixelRatio,this.canvas.height=n*this.lastDevicePixelRatio,this.offset.x+=r*(s-t),this.offset.y+=a*(n-i),this.queueDraw()}hitTest(e){const{sprites:t,x:i,y:r,width:a,height:s,inclusive:n}=e;if(!Array.isArray(t))throw new Error("Hit testing requires an array of candidate sprites");if(isNaN(i)||isNaN(r))throw new Error("Hit testing requires numeric x and y coordinates");if(void 0!==a&&isNaN(a)||void 0!==s&&isNaN(s))throw new Error("If specified, width and height must be numeric");return this.hitTestParameters={sprites:t,x:i,y:r,width:a||0,height:s||0,inclusive:void 0===n||!!n},t.length?(function(e){const{sprites:t,width:i,height:r,inclusive:a}=e.hitTestParameters;e.hitTestCount=t.length;const s=e.hitTestOutputResults.subarray(0,e.hitTestCount);if(!(a||i&&r))return console.warn("Inclusive hit test on a box with zero size always misses"),void s.fill(-1);const n=e.instanceHitTestInputUvValues,o=e.instanceHitTestInputIndexActiveValues,l=e.instanceSwatchUvValues;for(let e=0;e<t.length;e++){const i=t[e],r=i[I].index||0;n[2*e]=l[2*r],n[2*e+1]=l[2*r+1],o[2*e]=r,o[2*e+1]=i.isActive?1:0}e.instanceHitTestInputUvBuffer(n.subarray(0,2*e.hitTestCount)),e.instanceHitTestInputIndexActiveBuffer(o.subarray(0,2*e.hitTestCount)),e.hitTestCommand();const h=Math.ceil(e.hitTestCount/e.hitTestAttributeMapper.swatchesPerRow);e.regl.read({x:0,y:0,width:e.hitTestAttributeMapper.textureWidth,height:h,data:e.hitTestOutputValues,framebuffer:e.hitTestOutputValuesFramebuffer});const{totalSwatches:c}=e.hitTestAttributeMapper,d=e.hitTestOutputValues;for(let t=0;t<e.hitTestCount;t++){const e=(d[4*t]/16777216+d[4*t+1]/65536+d[4*t+2]/256+d[4*t+3])/255;s[t]=e*(c+1)-1}}(this),this.hitTestOutputResults.subarray(0,t.length)):new Float32Array(0)}doDraw(){this.initView();const e=this.elapsedTimeMs();this.isViewInitialized?this.drawCommand():console.warn("Skipping draw: view is not initialized"),this.toDrawTsRange.isDefined&&(this.toDrawTsRange.truncateToWithin(e,1/0),this.queueDraw(!1))}queueDraw(e=!0){this.queueTask(this.drawTaskId,(()=>{this.doDraw()}),e)}snapshot(){return a(this,void 0,void 0,(function*(){return new Promise(((e,t)=>{this.canvas.toBlob((i=>{i?e(i):t(i)}))}))}))}getViewMatrix(){if(!this.lastDevicePixelRatio)throw new D("initView must set lastDevicePixelRatio");const e=2*this.lastDevicePixelRatio;return[this.scale.x*e,0,0,0,this.scale.y*-e,0,this.offset.x*e,this.offset.y*e,1]}getViewMatrixScale(){if(!this.lastDevicePixelRatio)throw new D("initView must set lastDevicePixelRatio");const e=2*this.lastDevicePixelRatio,t=this.scale.x*e,i=this.scale.y*e;return[t,i,1/t,1/i]}getProjectionMatrix({viewportWidth:e,viewportHeight:t}){return[1/e,0,0,0,-1/t,0,-1,1,1]}getNextIndex(){if(!this.removedIndexRange.isDefined)return this.sprites.length<this.attributeMapper.totalSwatches?this.sprites.length:void 0;const{lowBound:e,highBound:t}=this.removedIndexRange;for(let i=e;i<=t;i++){if(this.sprites[i][I].lifecyclePhase===A.Removed)return i===t?this.removedIndexRange.clear():this.removedIndexRange.truncateToWithin(i+1,t),i}throw new D("No removed sprites found in removed index range")}createSprite(){const e=Object.seal(new G(this));if(this.waitingSprites.length>0||!this.removedIndexRange.isDefined&&this.sprites.length>=this.attributeMapper.totalSwatches)this.waitingSprites.push(e);else{const t=this.getNextIndex();if(void 0===t)throw new D("Next index undefined despite available capacity");this.assignSpriteToIndex(e,t)}return e}assignSpriteToIndex(e,t){const i=e[I];if(i.lifecyclePhase!==A.Created)throw new D("Only sprites in the Created phase can be assigned indices");const{valuesPerSwatch:r}=this.attributeMapper,a=this.targetValuesArray.subarray(t*r,(t+1)*r);a.fill(0),i.lifecyclePhase=A.Rest,i.index=t,i.spriteView=Object.seal(new V(a)),this.sprites[t]=e,this.instanceCount<=t+1&&(this.instanceCount=t+1)}markSpriteCallback(e){this.callbacksIndexRange.expandToInclude(e),this.queueRunCallbacks()}removeSprite(e){if(e.isRemoved)throw new D("Sprite can be removed only once");const t=e[I];t.index===this.instanceCount-1&&this.instanceCount--,t.lifecyclePhase=A.Removed,t.spriteView&&(t.spriteView[M]=void 0),void 0!==t.index&&this.removedIndexRange.expandToInclude(t.index)}queueTask(e,t,i=!1){this.workScheduler.isScheduledId(e)||this.workScheduler.scheduleTask({id:e,callback:t,beginImmediately:i})}queueRebase(){this.queueTask(this.rebaseTaskId,(()=>{!function(e){if(!e.needsRebaseIndexRange.isDefined)throw new D("No sprites are queued for rebase");e.rebaseCount=0;const{lowBound:t,highBound:i}=e.needsRebaseIndexRange;for(let r=t;r<=i;r++){const t=e.sprites[r][I];t.lifecyclePhase===A.NeedsRebase&&(e.needsTextureSyncIndexRange.expandToInclude(r),t.lifecyclePhase=A.NeedsTextureSync,e.instanceRebaseUvValues[2*e.rebaseCount]=e.instanceSwatchUvValues[2*r],e.instanceRebaseUvValues[2*e.rebaseCount+1]=e.instanceSwatchUvValues[2*r+1],e.rebaseCount++)}if(!e.rebaseCount)throw new D("No sprites were found to need rebase");e.queueTextureSync(),e.instanceRebaseUvBuffer(e.instanceRebaseUvValues.subarray(0,2*e.rebaseCount)),e.rebaseCommand(),e.previousValuesFramebuffer.use((()=>e.previousValuesTexture({copy:!0}))),e.needsRebaseIndexRange.clear()}(this)}))}queueAssignWaiting(){this.queueTask(this.runAssignWaitingTaskId,(e=>{!function(e,t,i){const{removedIndexRange:r,sprites:a,waitingSprites:s}=e;if(!r.isDefined)throw new D("No removed indices available to assign");if(!s.length)throw new D("No waiting sprites to assign");let n=0,o=r.lowBound,l=1,h=!1;for(;n<s.length&&o<=r.highBound&&!(n>0&&l++%i==0&&t()<=0);){for(;n<s.length&&s[n][I].isAbandoned;)n++;if(n>=s.length)break;for(;o<=r.highBound&&!a[o].isRemoved;)o++;if(o>r.highBound)throw new D("Removed index range ended on a non-removed sprite");const t=s[n],i=a[o][I],l=t[I];if(void 0===i.index)throw new D("Removed Sprite lacks index");if(e.assignSpriteToIndex(t,i.index),void 0===l.index)throw new D("Sprite index was not assigned");l.hasCallback&&(h=!0,l.lifecyclePhase=A.HasCallback,e.callbacksIndexRange.expandToInclude(l.index)),n++,o++}s.splice(0,n),o>r.highBound?r.clear():r.truncateToWithin(o,r.highBound),h&&e.queueRunCallbacks(),s.length&&r.isDefined&&e.queueAssignWaiting()}(this,e,this.stepsBetweenRemainingTimeChecks)}))}queueRunCallbacks(){this.queueTask(this.runCallbacksTaskId,(e=>{!function(e,t,i){if(!e.callbacksIndexRange.isDefined)throw new D("Running callbacks requires a range of indices");const{lowBound:r,highBound:a}=e.callbacksIndexRange;let s,n;e.callbacksIndexRange.clear();let o=!1,l=!1;const h=e.elapsedTimeMs(),c=()=>{if(!n)throw new D("Attempted to re-run afterCallback steps");const{spriteView:t,index:i}=n;if(!t||void 0===i)throw new D("Sprite missing required properties");t.TransitionTimeMs+=h,e.toDrawTsRange.expandToInclude(t.TransitionTimeMs+e.workScheduler.maxWorkTimeMs),t.TransitionTimeMs>h?(o=!0,n.lifecyclePhase=A.NeedsRebase,e.needsRebaseIndexRange.expandToInclude(i)):(l=!0,n.lifecyclePhase=A.NeedsTextureSync,e.needsTextureSyncIndexRange.expandToInclude(i),n.toBeRemoved&&!n.hasCallback&&t[M].fill(0)),s=void 0,n=void 0};let d=r;try{let h=1;for(;d<=a&&!(d>r&&h++%i==0&&t()<=0);){if(s=e.sprites[d],n=s[I],d++,n.lifecyclePhase!==A.HasCallback)continue;if(!n.spriteView)throw new D("Sprite in HasCallback lifecycle phase missing SpriteView");let t;if(n.enterCallback)t=n.enterCallback,n.enterCallback=void 0;else if(n.updateCallback)t=n.updateCallback,n.updateCallback=void 0;else{if(!n.exitCallback)throw new D("Sprite in HasCallback state missing callbacks");t=n.exitCallback,n.exitCallback=void 0}n.spriteView.TransitionTimeMs=e.defaultTransitionTimeMs,h=0,t.call(s,n.spriteView),c()}}catch(e){throw n&&n.lifecyclePhase===A.HasCallback&&c(),e}finally{o&&e.queueRebase(),l&&e.queueTextureSync(),d<=a&&(e.callbacksIndexRange.expandToInclude(d),e.callbacksIndexRange.expandToInclude(a)),e.callbacksIndexRange.isDefined&&e.queueRunCallbacks(),e.toDrawTsRange.isDefined&&e.queueDraw()}}(this,e,this.stepsBetweenRemainingTimeChecks)}))}queueRemovalTask(){this.queueTask(this.runRemovalTaskId,(e=>{!function(e,t,i){if(!e.toBeRemovedIndexRange.isDefined||!e.toBeRemovedTsRange.isDefined)throw new D("No sprites are queued for removal");const r=e.elapsedTimeMs();if(r<e.toBeRemovedTsRange.lowBound)return void e.queueRemovalTask();const{lowBound:a,highBound:s}=e.toBeRemovedIndexRange;e.toBeRemovedIndexRange.clear(),e.toBeRemovedTsRange.clear();let n=a;try{let o=1;for(;n<=s&&!(n>a&&o++%i==0&&t()<=0);n++){const t=e.sprites[n][I];if(t.toBeRemoved&&t.lifecyclePhase===A.Rest){if(!t.spriteView||void 0===t.index)throw new D("Sprite missing required properties");t.spriteView.TransitionTimeMs>r?(e.toBeRemovedIndexRange.expandToInclude(n),e.toBeRemovedTsRange.expandToInclude(t.spriteView.TransitionTimeMs)):(t.spriteView[M].fill(0),t.lifecyclePhase=A.NeedsTextureSync,e.needsTextureSyncIndexRange.expandToInclude(t.index))}}}finally{if(e.needsTextureSyncIndexRange.isDefined&&e.queueTextureSync(),n<s){e.toBeRemovedIndexRange.expandToInclude(n+1),e.toBeRemovedIndexRange.expandToInclude(s);for(let t=n+1;t<=s;t++){const i=e.sprites[t][I];if(!0===i.toBeRemoved&&i.lifecyclePhase===A.Rest){if(!i.spriteView)throw new D("Sprite lacks a SpriteView");e.toBeRemovedTsRange.expandToInclude(i.spriteView.TransitionTimeMs)}}}e.toBeRemovedIndexRange.isDefined&&e.queueRemovalTask()}}(this,e,this.stepsBetweenRemainingTimeChecks)}))}queueTextureSync(){this.queueTask(this.textureSyncTaskId,(()=>{!function(e){if(!e.needsTextureSyncIndexRange.isDefined)throw new D("No sprites are in need of texture sync");const{swatchesPerRow:t,textureWidth:i,valuesPerRow:r}=e.attributeMapper;if(e.needsRebaseIndexRange.isDefined){const i=O(e.needsRebaseIndexRange,t);if(O(e.needsTextureSyncIndexRange,t).overlaps(i))return e.queueRebase(),void e.queueTextureSync()}const{lowBound:a,highBound:s}=e.needsTextureSyncIndexRange,n=Math.floor(a/t),o=Math.floor(s/t)+1,l=o-n,h=e.targetValuesArray.subarray(n*r,o*r);let c=!1,d=!1;const u=e.elapsedTimeMs(),p=n*t,f=Math.min(o*t-1,e.sprites.length-1);for(let t=p;t<=f;t++){const i=e.sprites[t],r=i[I];if(r.lifecyclePhase===A.NeedsRebase)throw new D("Sprite is in the wrong lifecycle phase for sync");if(r.lifecyclePhase===A.NeedsTextureSync){if(!r.spriteView)throw new D("Sprite queued for texture sync lacks a SpriteView");r.hasCallback?(c=!0,r.lifecyclePhase=A.HasCallback,e.callbacksIndexRange.expandToInclude(t)):r.toBeRemoved?r.spriteView.TransitionTimeMs<=u?e.removeSprite(i):(d=!0,r.lifecyclePhase=A.Rest,e.toBeRemovedIndexRange.expandToInclude(t),e.toBeRemovedTsRange.expandToInclude(r.spriteView.TransitionTimeMs)):r.lifecyclePhase=A.Rest}}e.waitingSprites.length&&e.removedIndexRange.isDefined&&e.queueAssignWaiting(),c&&e.queueRunCallbacks(),d&&e.queueRemovalTask(),e.needsTextureSyncIndexRange.clear();const g={data:h,width:i,height:l};e.targetValuesTexture.subimage(g,0,n)}(this)}))}createSelection(){return new H(this.stepsBetweenRemainingTimeChecks,this)}createTextSelection(){return new _(this.stepsBetweenRemainingTimeChecks,this,this.workScheduler,this.glyphMapper)}}e.Scene=class{constructor(e={}){this[B]=new ee(e)}get scale(){return this[B].scale}get offset(){return this[B].offset}get canvas(){return this[B].canvas}resize(e){this[B].resize(e)}elapsedTimeMs(){return this[B].elapsedTimeMs()}createSprite(){return this[B].createSprite()}hitTest(e){return this[B].hitTest(e)}createSelection(){return this[B].createSelection()}createTextSelection(){return this[B].createTextSelection()}},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=megaplot-v0.1.2.es2015.min.js.map
